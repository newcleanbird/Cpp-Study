# 类与对象
## 类的定义
C++中的类可以看成C语言中的结构体升级版，结构体是一种构造类型，可以包含若干成员变量，成员变量的类型可以不同。
```cpp
class name
{
    //类体：成员函数和成员对象
};
```
关于class（类）的几点说明：
1. 类的定义的最后有一个分号，它是类的一部分，表示类定义结束，不能省略。
2. 一个类可以创建多个对象，每个对象都是一个变量
3. 类是一种构造类型，大小的计算方法和struct一样，需要字节对齐
4. 类成员变量的访问方法：通过 .或者->来访问
5. 成员函数是类的一个成员，出现在类中，作用范围由类来决定，而普通函数是独立的，作用范围是全局或者某个命名空间

struct ：内部默认是共有权限，结构体外部可以访问其内部成员
class：内部默认是私有权限，类的外部不能直接访问内部成员；可以手动声明为共有权限;

### 定义方式
1. 声明和定义放在类内，对于成员函数如果放在类内定义，编译器可能会将其当为内联函数处理。
2. 声明和定义分离
```cpp
class ClassName {
public:          // 访问权限修饰符，这里是公共访问权限
    // 成员变量（数据成员）定义
    int dataMember1;
    double dataMember2;

    // 成员函数（方法）定义
    ClassName();     // 构造函数声明
    ~ClassName();    // 析构函数声明

    void someMethod();   // 其他成员函数声明

protected:         // 受保护的访问权限修饰符
    // 受保护的成员变量和函数可以被本类及继承类访问
    float protectedDataMember;

private:            // 私有访问权限修饰符
    // 私有成员只能被本类成员函数访问
    char privateDataMember;

    // 成员函数定义也可以放在类体内
    void privateMethod() {
        // 实现细节
    }
};

// 类外定义成员函数
ClassName::ClassName() {       // 构造函数定义
    // 初始化代码
}

ClassName::~ClassName() {      // 析构函数定义
    // 清理工作
}

void ClassName::someMethod() {  // 成员函数定义
    // 函数实现
}
```

### 类的访问限定符
1. Public（公有）
- 定义：public成员对所有用户都是可见的，无论是在类的内部还是外部，甚至是类的非成员函数和派生类中。
- 用途：通常用于类的接口部分，即那些希望外部用户能够直接访问和操作的成员，如公共方法（成员函数）和某些属性（数据成员）。

2. Protected（受保护）
定义：protected成员在类的外部不可见，但在类的派生类（子类）中是可见的，以及在类的内部。
用途：用于设计类的继承结构时，想要让基类的某些成员在派生类中可用，但不希望这些成员成为公共接口的一部分。

3. Private（私有）
定义：private成员仅在类的内部可见，对于类的外部以及派生类都是不可见的。
用途：用来隐藏类的实现细节，保护数据不被外部直接访问，通常用于数据成员，以实现封装和数据安全。

- 访问限定符的使用规则
  - 类的默认访问级别是private，如果不显式指定访问限定符，则成员默认为私有。
  - 结构体（struct）的默认访问级别是public，与类不同。
  - 访问限定符可以多次出现在类定义中，每次出现都影响其后的成员声明，直到遇到下一个访问限定符。
  - friend关键字可以被用来指定类的友元，友元可以访问类的私有和受保护成员。

#### 深入理解访问限定符
1. Public（公有）
- 思想：体现的是**接口暴露**的思想。公有成员是类对外提供的接口，是类与外部世界交流的桥梁。外部代码通过调用公有成员函数来与对象交互，而不必关心对象内部的具体实现细节。这符合封装原则，即隐藏实现细节，只暴露必要的接口。
- 关系：公有成员是类的用户（客户端代码）与类之间的直接联系。它允许类的使用者自由地读取和修改（如果是变量的话），或者调用（如果是函数的话）这些成员，从而利用类的功能。

2. Protected（受保护）
- 思想：代表了**继承与扩展**的设计思想。受保护成员在类的直接使用者面前是隐藏的，但是对派生类开放。这意味着基类设计者打算允许其继承者访问这些成员，以便在不破坏基类封装的前提下进行功能的扩展或修改。这支持了面向对象编程中的继承特性。
- 关系：受保护成员在类的层次结构中起到了承上启下的作用，它连接了基类和派生类，使得派生类能够访问并可能重定义基类的部分内部操作，同时保持这些操作对非继承关系的外部代码的不可见性。

3. Private（私有）
- 思想：强调**封装与隐藏**。私有成员是类的内部实现细节，对外界完全隐藏。这一设计确保了类的内部数据和实现逻辑不会被外部代码无意或恶意地修改，有助于维护类的完整性和稳定性。私有成员的存在使得类能够控制对其状态的访问和修改方式，是实现信息隐藏和封装的关键。
- 关系：私有成员与类的其他部分（特别是公有成员函数）之间形成了内部协作的关系，公有函数作为对外的接口，管理对私有数据的访问。这种设计模式鼓励了数据抽象，即将复杂的数据处理过程隐藏在简单易用的接口之后。

### 类的作用域
1. 定义与范围：类的作用域是由一对花括号 {} 包围的区域，定义了类的所有成员。在这个作用域内声明的任何名称（变量、函数等）都只在这个类内部有效。
2. 在类的作用域内，成员可以直接通过名称引用，无需额外的限定符。而在类的外部，访问类的非静态成员时，需要通过对象实例、引用或指针结合成员访问运算符（.或->）。
3. 静态成员（包括数据成员和成员函数）在类的作用域内定义，但它们不依赖于类的任何特定实例。静态成员可以通过类名直接访问，即使没有类的实例。
4. 外部定义：当在类定义外部实现成员函数时，需要使用作用域解析运算符 :: 来指定该函数属于哪个类。例如，ClassName::memberFunction() 表明 memberFunction 是 ClassName 类的成员。
5. 枚举与常量：类作用域内可以定义枚举和常量，这有助于封装和避免名称冲突，同时也使得这些元素在类的整个生命周期内保持一致性和可访问性。

### 类的实例化（创建对象）
类的实例化指的是根据类定义创建类的对象的过程。对象是类的实例，它包含了类定义的数据成员和成员函数。创建类的对象后，就可以通过这个对象来访问和操作类的成员。以下是创建对象的基本步骤和注意事项：

1. 创建对象的基本语法
```cpp
ClassName objectName;
```
- ClassName 是类的名称。
- objectName 是你给对象取的名字，也就是对象的实例名。

2. 注意事项
- 默认构造函数：如果类没有定义任何构造函数，编译器会自动生成一个默认构造函数，用于初始化对象。如果有自定义构造函数，需要显式调用或由编译器根据情况选择合适的构造函数。
- 内存分配：每个对象在内存中都会分配独立的空间，用于存储其数据成员的值。因此，即使创建了多个相同的类的对象，每个对象的数据也是独立的。
- 动态对象：除了在栈上创建对象，还可以使用 new 操作符在堆上动态创建对象。动态对象需要手动使用 delete 释放内存。

### 类对象的大小（sizeof）
- 一个类的大小，是成员变量大小之和，（存在内存对齐）。
[内存对齐](../编译内存相关/内存对齐.md)

- 注意对于空类实例化的对象的大小，空类的大小为1，因为编译器给空类一个字节来表示这个类实例化的对象，（可以认为这个类实例化的对象存在的证明）（也就是占位）。
  - 唯一地址需求：每个对象在内存中都必须有一个唯一的地址。如果空类的大小为0字节，那么多个这样的实例在内存中将会占用同一位置，导致它们无法拥有不同的地址，从而无法区分。
  - 编译器实现：为了确保每个空类实例至少占有一定的内存空间，编译器通常会自动为空类添加一个字节的隐藏成员，即使类定义中没有显式声明任何内容。这样做使得每个空类实例化后的对象在内存中都有一个独一无二的地址。
  - 对齐与优化：虽然空类实例因为这个隐藏字节而占用1字节，但在某些情况下，如空类作为基类参与多态或继承时，编译器可能会实施空基类优化（Empty Base Class Optimization, EBCO），以减少空基类在派生类对象中的内存占用。这意味着在实际的复杂对象布局中，空类可能不会造成额外的内存开销。

### this指针
```cpp
Date d;
d.print();
```
由于成员函数放在公共的代码段中。将类可以实例化出来的不同对象，调用各自的非静态成员函数时，该函数为了知道是哪个对象调用的，该非静态成员函数会有有个隐藏的this指针，指向该函数的对象，是编译器自动调用的。那么这个处于公共代码段非静态成员函数就可以通过指向某个对象的this指针指到是哪个对象调用的了（从而实现对每个对象的成员变量的修改）。

#### this指针的特性
1. 类型：类的类型*const （this指针不可改，指向的内容可改）。
2. 只能在非静态成员函数中使用，静态成员函数没有this指针。
3. 本质是成员函数的第一个形参（隐含的）。

#### 深入理解this指针
```cpp
#include <iostream>
using namespace std;

class A
{
public:
	void PrintA()
	{
		cout << _a << endl;
	}
	void Show()
	{
		cout << "Show()" << endl;
	}
private:
	int _a;
};

int main()
{
	A* p = nullptr;
	//p->Show();       //第一句代码
	//p->PrintA();     //第二句代码
}
```
运行第一行代码时，虽然p是空指针，但是它在show函数中是作为形参传到了隐藏的this指针中，而这个this指针在这个函数中并没有解引用，所以程序不会崩溃。

而对于PrintA()函数，由于里面有对this形参的解引用，就会崩溃。

### c++11声明时给缺省值 
注意这不是初始化
```cpp

class Date
{
	//对象实例化必须要有构造函数
    public:
	void Print()
	{
	    cout << _day << "/" << _month << "/" << _year<<endl;
    }
	int _day=1;//声明时给缺省值 
    int _month=2;
    int _year=3;
    A _aa;
};
```
- 如果初始化列表有初始化，那么就不用声明给的缺省值，
- 初始化列表没有初始化，那么就用声明时给的缺省值，
- 如果声明时也没有给缺省值，那么就是随机值了

## 类的默认成员函数
默认的其中一个含义：你不显式写，系统会默认生成。（只是其中一个含义会面会讲其他含义）
1. 默认构造函数（Default Constructor）：如果一个类没有定义任何构造函数，编译器会自动生成一个默认构造函数，这个构造函数不接受任何参数，用于默认初始化类的对象。

2. 拷贝构造函数（Copy Constructor）：当一个新对象被初始化为已存在对象的副本时调用。如果未自定义，编译器会生成一个，该函数复制所有非静态数据成员。

3. 赋值运算符重载函数（Assignment Operator）：用于将一个对象的值赋给另一个同类型的对象。如果未自定义，编译器会提供一个默认的，它按位复制数据成员。

4. 析构函数（Destructor）：当对象生命周期结束时自动调用，用于释放对象所占用的资源。如果没有自定义，编译器会生成一个空的析构函数。

自从C++11引入移动语义之后，还有另外两个与右值引用相关的默认成员函数：

5. 移动构造函数（Move Constructor）：用于从一个临时对象或即将销毁的对象高效地“移动”资源到新对象，而非复制资源。如果类中有动态分配的内存或其他可移动资源，并且没有自定义移动构造函数，编译器会生成一个。

6. 移动赋值运算符（Move Assignment Operator）：与移动构造函数类似，用于将一个临时对象或即将销毁的对象的资源移动到已有对象上，以替代其当前的值。同样，如果未自定义且适用，编译器会自动生成。

除此之外，还有两个与取地址相关的操作符也可能有默认实现，尽管它们不是针对特定对象的操作：

7. 取地址操作符（Address-of Operator）：返回对象的地址，通常不需要也不应该被重载，除非有特殊需求。

8. 常量取地址操作符（Const Address-of Operator）：返回对象的常量地址，当对象本身是常量时使用，同样，通常不需要重载。

### 构造函数
1. 目的
保证每一个成员变量有一个初始值。

2. 特性
    1. 函数名与类名相同。
    2. 无返回值。
    3. 对象实例化时编译器自动调用对应的构造函数，类实例化时必须要有构造函数
    4. 构造函数可以重载
    5. **没有显式定义构造函数则编译器会生成一个无参的默认构造函数，如果有显式定义编译器不再生成**
    6. 系统默认生成的构造函数对自定义类型调用自己的构造函数，内置类型不做处理

```cpp
Date d1;    // 默认构造无参
Date d2();  // 无参不能加括号 错误！无法区分函数声明
```

#### 默认构造函数（Default Constructor）
- 无参数：默认构造函数不接受任何参数。这是它区别于其他构造函数（如带参数构造函数）的主要标志。

- 自动调用：当创建一个类的对象且没有提供初始化列表或参数时，编译器会自动调用默认构造函数。此外，在数组或容器初始化等场景中，如果没有显式提供初始化值，也会调用默认构造函数。

- 编译器生成：如果程序员没有显式定义任何构造函数，编译器会自动为类生成一个默认构造函数。这个默认构造函数可能什么都不做（无用的默认构造函数），或者如果类的数据成员有类内初始值（C++11起支持），则会用这些初始值来初始化数据成员。

- 初始化：默认构造函数会执行以下操作之一：
  - 对于基类子对象和成员类对象，它会调用它们的默认构造函数（递归进行）。
  - 对于数据成员，如果它们是POD（Plain Old Data）类型且没有类内初始值，则默认构造函数不会执行特别的初始化操作，这些成员将保持未初始化状态或默认初始化状态（数值类型通常为0或NULL，指针类型为NULL）。
  - 如果数据成员有类内初始值（C++11起），则使用这些初始值进行初始化。

- 覆盖与抑制：一旦程序员定义了任何构造函数（即使是其他带参数的构造函数），编译器将不再自动生成默认构造函数。如果仍然需要默认构造函数的行为，可以显式定义一个不带参数的构造函数，并且可以选择使用=default关键字来显式要求编译器生成默认构造函数的行为。

- 使用``=default``和``=delete``：C++11引入了=default和=delete语法，允许程序员显式要求使用或禁止生成默认构造函数。=default可以用来明确指定即使类中还有其他构造函数，也要生成一个默认构造函数。=delete则可以用来禁止生成默认构造函数，防止类被默认实例化。


#### 初始化列表
1. 语法：初始化列表位于构造函数的头部，紧跟在构造函数的参数列表之后，由一个冒号（:）引导，随后是用逗号分隔的成员变量初始化器列表。
```cpp
ClassName::ClassName(arg1, arg2) : member1(value1), member2(value2), ...
{
    // 构造函数体
}
```
2. 作用：
- 效率：对于非静态的非POD（Plain Old Data）类型成员，如自定义类的对象，直接初始化可以避免两次构造（一次默认构造再赋值）。
- 必须使用：对于**常量成员**、**引用类型成员** 和 **自定义类型的成员(没有默认构造函数)**，必须使用初始化列表，因为这些成员在声明后不能被赋值。
  - 即：这些变量都是在定义时就要给初始值进行初始化的。
- 基类构造：同样，如果类从基类继承，可以通过初始化列表来调用基类的构造函数。

3. 初始化顺序：成员变量的初始化顺序与其在类声明中的声明顺序一致，而非初始化列表中的顺序。

4. 优化资源分配：直接初始化可以避免不必要的临时对象创建，尤其是当成员变量是复杂类型或者初始化开销较大时。

5. 编译器行为：如果在构造函数体内使用赋值操作符初始化成员变量，这实际上是进行了默认构造后再赋值的操作，对于某些类型可能不够高效，也不适用于常量或引用成员。

注意：
1. 构造函数中的语句只能将其赋值（可以多次）, 不叫初始化（只能初始化一次，即每个成员对象只能在初始化列表中出现一次）

2. 初始化列表有值则用初始化列表的 不用声明时给缺省值的缺省值 而是用构造函数的缺省值

#### 隐式类型转化  explicit 
- 作用：explicit 修饰的构造函数有禁止隐式类型转换
![explicit](/关键字与限定符/explicit.md)


### 析构函数
析构函数在C++中是一个特殊的成员函数，它没有返回类型（连void也没有），也没有参数。析构函数的主要职责是在对象生命周期结束时执行清理工作，释放对象可能占用的资源。
1. 作用
- 主要清理堆区的资源，防止内存泄漏
- 要显示写拷贝构造函数一般就要显示写析构函数，（因为涉及深浅拷贝问题）

2. 特性
   1. 自动调用：析构函数是自动执行的，不需要程序员显式调用。当对象生命周期结束时，如对象离开作用域、delete一个动态分配的对象、容器（如std::vector）销毁其元素时，析构函数会被自动调用。
   2. 资源清理：析构函数主要用于释放对象占用的资源，如动态分配的内存、关闭文件、断开网络连接等。这有助于避免资源泄露，保持程序的健壮性。
   3. 生命周期管理：与构造函数相对应，构造函数用于初始化对象，而析构函数负责清理。它们共同构成了对象的完整生命周期管理。
   4. 继承与组合：
      1. 继承：在继承体系中，当派生类的析构函数执行完毕后，会自动调用基类的析构函数，保证基类资源也被正确释放。析构顺序与构造顺序相反。
      2. 组合：如果一个类中有其他类的对象作为成员，该成员对象的析构函数会在本类析构函数之前被调用，遵循“后构造先析构”的原则。
   5. 默认析构函数：如果开发者没有显式定义析构函数，编译器会自动生成一个默认的析构函数。默认析构函数通常不做任何操作，但对于不管理额外资源的基本类来说已足够。对于管理了资源的类，应当自定义析构函数以确保资源正确释放。
   6. 虚析构函数：在有多态需求的情况下，基类的析构函数应声明为虚拟的（virtual），以确保通过基类指针或引用来删除派生类对象时，派生类的析构函数能够被正确调用，避免资源泄露。

3. 析构顺序
- 先实例的对象先构造后析构
  - 为什么：因为对象是在函数中实例化的，函数调用会建立函数栈帧，对象的构造类似栈的先入后出。
- 构造顺序：全局对象（从上往下）-> 局部静态 -> 局部对象
- 销毁循序：局部对象（后定义先销毁）-> 局部静态 -> 全局对象(后定义先销毁)

即：
1. 数据成员的析构：首先，按照它们在类中声明的逆序调用类中非静态数据成员的析构函数。这是因为最后一个构造的数据成员应该是第一个被析构的。

2. 当前类析构函数体：接下来，执行当前类析构函数的函数体。这是用户定义的代码部分，用于执行特定的清理工作。

3. 基类析构：如果当前类是从另一个类继承而来，那么按照继承顺序的逆序调用基类的析构函数。最直接的基类的析构函数最后被调用，而离当前类最远的基类析构函数首先被调用。

4. 虚继承的处理：对于虚继承的情况，虚基类的析构函数会在所有派生类的析构完成后被调用，以确保虚基类的资源只被释放一次。这通常在所有非虚基类的析构函数调用之后发生。

简而言之，析构的顺序确保了从最“内部”的（最近构造的）部分开始析构，向外（最早构造的部分）进行，直到最终的基类和虚基类。这样的设计有助于避免资源泄露和确保正确的资源管理，尤其是在涉及到复杂对象层次结构和继承关系时。

### 拷贝构造
拷贝构造函数是C++中一个特殊的构造函数，其主要职责是使用一个已经存在的同类对象来初始化一个新的对象。拷贝构造函数允许你创建一个类的新实例，并将其初始化为现有实例的一个精确副本，包括所有的数据成员和资源。下面是关于拷贝构造函数的详细说明：

#### 定义
拷贝构造函数的定义具有以下特征：
- 函数名：与类名相同。
- 参数：仅有一个参数，该参数是对本类类型的对象的引用。为了防止实参被修改，通常使用const修饰，即const 类名 &。
- 返回值：没有返回值，连void也不需要指定。
- 访问权限：应当声明为public，以便在需要时可以从外部访问。

示例：
```cpp
class MyClass {
public:
    // 拷贝构造函数
    MyClass(const MyClass &other) {
        // 执行深拷贝或其他必要的初始化操作
        this->data = new int(*other.data); // 假设data是一个int指针，执行深拷贝
    }
    
private:
    int *data; // 成员变量
};
```

#### 写法注意
**注意：容易写出无穷递归**
```cpp
//拷贝构造
    Date(Date d)//调用拷贝构造 要传值传参 又要构造拷贝构造 无穷递归
    {
        _day = d._day;
        _month = d._month;
        _year = d._year;
    }
    *****************************以上错误例子
 
    Date(const Date& d)正确写法
    {
        _day  = d._day;
        _month = d._month;
        _year = d._year;
    }
```


#### 调用时机
拷贝构造函数会在以下几种情况下被自动调用：

1. 直接初始化：用一个已存在的对象直接初始化一个新对象时。
```cpp
MyClass obj1;
MyClass obj2(obj1); // 调用了拷贝构造函数
```

2. 作为函数参数传递：当对象作为参数以值传递给函数时。
```cpp
void func(MyClass obj);
MyClass obj1;
func(obj1); // 在这里调用拷贝构造函数创建obj的副本传递给func
```

3. 作为函数返回值：函数以类对象作为返回值且返回的是局部对象或参数对象时。
```cpp
MyClass func() {
    MyClass localObj;
    return localObj; // 返回前调用拷贝构造函数
}
MyClass obj = func(); // 调用拷贝构造函数接收返回值
```

4. 赋值操作的副产品：虽然这不是直接调用拷贝构造函数的场景，但在某些旧的编译器或特定情境下，复杂的赋值操作可能间接触发拷贝构造函数（现代编译器通常会对这种情况进行优化，使用移动构造函数或复制省略优化）。

#### 浅拷贝与深拷贝
- 浅拷贝：默认的拷贝构造函数执行的是浅拷贝，即只复制对象的非静态数据成员的值，如果成员是指针，则只复制指针的值，而不是指针所指向的数据。这可能导致两个对象共享同一块内存，当其中一个对象修改这块内存时，会影响到另一个对象。

- 深拷贝：为了避免浅拷贝带来的问题，需要自定义拷贝构造函数来执行深拷贝，即除了复制指针的值外，还为新对象分配新的内存，并复制原对象指针所指向的数据。

**需要深拷贝的情况**：
1. 含有指针成员变量的类：当类中包含指向动态分配内存的指针成员时，必须执行深拷贝以确保每个对象拥有其数据的独立副本。否则，浅拷贝会导致两个对象共享同一块内存，从而在对象生命周期管理上出现问题，比如重复释放同一块内存。

2. 资源管理类：如文件句柄、数据库连接、网络套接字等资源的封装类。这类对象需要确保每个实例管理独立的资源，深拷贝可以保证复制的对象拥有自己的资源副本，避免资源共享导致的冲突或错误。

3. 容器类：如果你自定义了包含其他对象或指针的容器（如数组、链表、树等），并且这些元素也需要独立存在，则容器的拷贝需要执行深拷贝，以确保容器内的每一个元素都是独立的副本。

4. 包含复杂数据结构的类：如果类中嵌套了其他复杂类型，特别是那些含有指针或动态分配的成员，深拷贝就显得尤为重要。这包括类的类成员、自定义数据结构等。

5. 图形对象或大对象：在处理图像、声音、视频等大型数据对象时，由于数据量大且通常是动态分配的，深拷贝可以确保每个对象有其专属的数据缓冲区，避免数据错乱。

6. 多线程环境下的共享数据：在多线程应用中，为了线程安全，可能需要为每个线程提供独立的数据副本，此时深拷贝是必要的，以防止数据竞争和一致性问题。

### 拷贝赋值运算符 / 赋值运算符重载函数
赋值运算符重载函数，也称为拷贝赋值运算符，是C++中一种特殊的成员函数，用于定义当使用赋值运算符(=)将一个对象的值赋予另一个对象时的行为。这个函数允许你控制对象之间如何进行值的复制，特别是在涉及复杂数据结构或资源管理时，自定义赋值运算符重载函数变得尤为重要。

#### 定义
赋值运算符重载函数的一般形式如下：
```cpp
class MyClass {
public:
    // 赋值运算符重载函数
    MyClass& operator=(const MyClass& other) {
        // 实现赋值逻辑
        if (this != &other) { // 防止自我赋值
            // 深拷贝或其他必要的赋值操作
            data = new int(*other.data); // 假设data是一个int指针，执行深拷贝
        }
        return *this; // 返回当前对象的引用，支持链式赋值
    }

private:
    int* data; // 成员变量
};
```

#### 特点
1. 返回类型：通常返回当前对象的引用(MyClass&)，这样可以支持连续赋值，如a = b = c。
2. 参数：一个常量引用到同类对象(const MyClass& other)，这避免了不必要的拷贝，并允许对const对象进行赋值。同时，加const可以防止在赋值过程中修改源对象。
3. 自我赋值检查：在赋值逻辑开始前，通过检查this != &other来判断是否为自我赋值，这一步是防止自我赋值导致的问题，如重复释放内存。
4. 深拷贝：如果类中包含指针成员，需要执行深拷贝，即复制指针所指向的数据，而不是仅仅复制指针的值。
5. 资源管理：确保正确地处理和转移资源（如内存、文件描述符等），并释放原有资源，避免资源泄露。

#### 何时需要重载
1. 当类中含有动态分配的内存或资源时。
2. 当类需要执行特殊的逻辑或验证，在赋值操作发生时。
3. 为了提升效率，避免不必要的操作，如当对象非常大或复杂时。

#### 注意事项
1. 返回值：返回当前对象的引用可以让赋值操作支持连续赋值。
2. 异常安全：在实现过程中要考虑异常安全，确保即使在发生异常时也不会留下资源泄露。
3. 复制省略与移动语义：C++11引入了移动语义，有时使用移动赋值运算符比拷贝赋值更高效。如果适用，应同时考虑重载移动赋值运算符。
4. 避免无穷递归：如果在赋值运算符中直接或间接调用了自身，确保有终止条件，避免无限递归。


#### 区分拷贝构造 和 拷贝赋值运算符
- 拷贝构造函数（Copy Constructor）
  1. 用途：拷贝构造函数用于创建一个新对象作为现有对象的副本。它在以下情况下被调用：
     1. 当用一个已存在的对象直接初始化另一个新对象时，如 MyClass obj2(obj1)
     2. 当函数以值传递方式返回一个对象时，需要在调用者处创建一个副本。
     3. 当以值传递方式向函数传递对象时，形参需要被初始化为实参的副本。
  2. 调用时机：在新对象的生命周期开始时，作为构造过程的一部分。
  3. 语法：``MyClass(const MyClass& original);``

- 拷贝赋值运算符（Copy Assignment Operator）
  1. 用途：拷贝赋值运算符用于将一个已有对象的值赋给另一个已存在的对象。它在以下情况下被调用：
     1. 当一个对象通过赋值操作符=被赋予另一个同类型对象的值时，如 obj1 = obj2
     2. 在循环体或条件语句中改变对象的值时。
  2. 调用时机：在对象的生命周期内，当对象已经存在，需要更新其状态为另一个对象的状态时。
  3. 语法：``MyClass& operator=(const MyClass& other);``

- 区别总结
  - 本质差异：拷贝构造函数用于创建新对象，而拷贝赋值运算符用于更新已有对象。
  - 调用时刻：拷贝构造函数在对象创建时调用，拷贝赋值运算符在对象已经存在后调用。
  - 返回值：拷贝构造函数没有返回值，而拷贝赋值运算符通常返回对当前对象（即被赋值的对象）的引用，以便支持连续赋值。
  - 资源管理：二者都需要考虑深拷贝与浅拷贝的问题，尤其是当类中有动态分配的资源时。拷贝构造函数总是创建新对象，而拷贝赋值则需特别注意避免自我赋值导致的资源泄露。

### 移动构造函数
移动构造函数是在C++11中引入的一个特性，旨在优化资源的转移和管理，特别是在处理大型对象或资源密集型对象时，以提高性能和减少不必要的拷贝操作。移动构造函数的基本概念和用途如下：


#### 定义
移动构造函数是一种特殊的构造函数，它的目的是将一个即将被销毁的对象（通常是一个临时对象或者一个将要被重新赋值的对象）的资源“移动”到新创建的对象中，而不是进行复制。这通常涉及到指针或资源所有权的直接转移，而不需要复制底层数据，从而可以更高效地利用资源。

#### 语法
移动构造函数的声明类似于拷贝构造函数，不同之处在于它接受一个右值引用作为参数：
```cpp
class MyClass {
public:
    // 移动构造函数
    MyClass(MyClass&& other) noexcept {
        // 将other的资源移动到*this，可能包括交换或直接赋值指针
        data = other.data; // 假设data是一个指针成员
        other.data = nullptr; // 确保other不再拥有资源
    }

private:
    int* data; // 成员变量
};
```

#### 调用时机
移动构造函数在以下几种情况自动被调用：

1. 临时对象赋值：将一个临时对象直接赋给一个新对象，如 MyClass obj = MyClass();
2. 返回值优化：当函数返回一个局部对象时，可以移动该对象到调用方，避免拷贝。
3. 容器操作：STL容器（如std::vector）在内部调整大小或重新分配内存时，可能会使用移动构造函数来转移元素，以提高效率。

#### 为何重要
- 性能提升：移动构造函数避免了深拷贝，特别是在处理大型对象或复杂数据结构时，显著提高了程序性能。
- 资源管理：通过直接转移资源所有权，避免了资源的复制和潜在的泄露风险。
- 无成本移动：对于那些资源持有者（如智能指针），移动操作可以是“无成本”的，即几乎立即完成，因为只需要更改几个指针或计数器。

#### noexcept
通常，移动构造函数会被标记为noexcept，这告诉编译器此操作不会抛出异常，使得编译器能够在更多场合安全地使用移动语义，进一步优化性能。
![noexcept](/关键字与限定符/noexcept.md)

### 移动赋值运算符
移动赋值运算符是C++11引入的一种特殊成员函数，用于优化资源管理，尤其是在处理大型对象或资源密集型对象的赋值操作时。它通过转移而非复制资源来提高效率，减少不必要的深拷贝。以下是移动赋值运算符的详细讲解：

#### 定义
移动赋值运算符是一个重载的赋值运算符，其参数是一个右值引用，用于接收一个即将被销毁或不再需要的对象的资源。它的返回值通常是当前对象的左值引用，并且通常会标记为noexcept以表明不会抛出异常。
```cpp
class MyClass {
public:
    // 移动赋值运算符
    MyClass& operator=(MyClass&& other) noexcept {
        if (this != &other) {
            // 将other的资源转移到*this
            delete data; // 释放当前对象的资源（如果有）
            data = other.data; // 获取other的数据指针
            other.data = nullptr; // 确保other不再拥有资源
        }
        return *this; // 支持连续赋值
    }

private:
    int* data; // 成员变量，假设是一个指向动态分配内存的指针
};
```

#### 调用时机
移动赋值运算符在以下情况下被调用：
1. 对象赋值给一个即将被销毁的临时对象：如 MyClass obj; obj = MyClass();
2. STL容器中的元素重排：当容器（如std::vector）在内部调整大小或重新分配内存时，可能会使用移动赋值来转移元素。
3. 返回值优化：函数返回局部对象且被直接赋值给一个已存在对象时，可能触发移动赋值。

#### 目的与优势
- 性能优化：避免了昂贵的深拷贝操作，特别是对于大对象或含有动态分配资源的对象，极大地提高了程序效率。
- 资源管理：直接转移资源的所有权，避免了资源的复制和原对象资源的泄露。
- 减少内存占用：在对象生命周期结束前，其拥有的资源能够迅速有效地被其他对象接管和复用。

#### 与拷贝赋值的区别
尽管移动赋值和拷贝赋值看起来相似，但它们的核心区别在于对待源对象的方式：

- 拷贝赋值会创建源对象数据的副本，两个对象最终拥有独立的数据副本。
- 移动赋值则“窃取”源对象的数据或资源，源对象通常被置为某种无效状态，不再拥有这些资源。

#### noexcept
由于移动操作理应不抛出异常（除非资源移动过程中发生了异常情况，这是极少见的），所以通常将移动赋值运算符标记为noexcept。这允许编译器做出更多优化决策，例如在标准库容器调整大小时优先选择移动而非拷贝。
![noexcept](/关键字与限定符/noexcept.md)

#### 实现细节
- 自我赋值检查：尽管在移动赋值中自我赋值的可能性较低，但仍建议实施检查，以确保操作的健壮性。
- 资源清理：确保在转移资源前，先释放当前对象持有的资源（如果有的话）。
- 置空原对象：将源对象的相关指针或资源引用设置为nullptr或其他无效状态，防止悬空指针问题。

### 地址操作符
取地址操作符在C++中是一个非常基础且重要的运算符，主要用来获取对象或变量在内存中的地址。它有两种形式，分别是一般形式的取地址运算符&和用于类类型的取地址运算符重载。

#### 一般形式的取地址运算符
1. 符号与用法：取地址运算符是一个前置的单目运算符，表示为&。当你在变量或对象前面放置这个运算符时，它会返回该变量或对象在内存中的地址。
例如：
```cpp
int x = 10;
int* p = &x; // p 存储了变量x的内存地址
```

2. 类型：取地址运算符的结果类型是一个指向其操作数类型的指针。如果x是一个int类型，那么&x的结果类型就是int*。

3. 作用对象：它可以应用于任何具有内存地址的实体上，包括普通变量、数组名、函数名以及类的非静态成员等。

#### 类类型的取地址操作符重载
对于类类型，C++允许重载取地址运算符。这意味着你可以自定义当取某个类对象地址时的行为，虽然这通常只对指针或引用成员有意义。

1. 重载形式：重载取地址运算符使用operator&，通常作为类的成员函数实现。它没有参数，返回类型是一个指向该类类型的指针。
例如：
```cpp
class MyClass {
public:
    MyClass* operator&() {
        return this; // 返回当前对象的地址
    }
};
```

2. 何时重载：重载取地址操作符通常不是必需的，除非有特殊需求，比如管理资源或实现复杂的指针逻辑。大多数情况下，编译器提供的默认行为已经足够。

3. 注意事项：重载取地址运算符时需要谨慎，确保不破坏对象的逻辑一致性，特别是处理自定义的资源管理类时。

### 常量取地址操作符
在C++中，常量取地址操作符的概念主要与取地址操作符(&)结合const关键字一起讨论，尤其是在涉及类和对象的上下文中。当我们谈论“常量取地址操作符”，实际上是指获取一个常量对象或常量成员的地址。这里有几个关键点需要理解：

#### 常量对象与取地址
1. 常量对象：当一个对象被声明为常量（使用const关键字），意味着该对象的值在其生命周期内不应被修改。例如：
```cpp
const int x = 10;
```
这里，x是一个常量整数，其值不能被改变。

2. 取常量对象的地址：尽管不能修改常量对象的值，但我们可以获取其地址，并且这个地址可以被存储在一个指向常量的指针中。这样的指针被称为const指针，它只能用于读取数据，不能修改数据：
```cpp
const int* ptr = &x; // ptr 是指向常量整数的指针
```

#### 类中的常量成员取地址
对于类中的常量成员，情况类似：

1. 常量成员函数中的this指针：在常量成员函数（由const关键字后置成员函数声明）内部，this指针是一个指向常量对象的指针（const MyClass* const this）。这意味着成员函数不能修改对象的任何成员，但可以获取这些成员的地址，包括常量成员的地址。

2. 常量成员取地址：如果你有一个类，其中包含常量成员，你可以从常量对象实例中获取这些常量成员的地址。这通常在重载取地址操作符或在类的内部实现中有所体现。

#### 重载取地址操作符与const
- 常量重载版本：当重载取地址操作符(operator&)时，通常会提供两个版本：一个用于非const对象，另一个用于const对象。这样可以确保无论对象是否为常量，都能正确地获取其地址。
```cpp
MyClass* operator&() { return this; } // 非const版本
const MyClass* operator&() const { return this; } // const版本
```

- const成员函数的约束：在const成员函数中，只能调用const版本的取地址操作符，这保证了对象的常量性不被违反。

#### 总结
常量取地址操作符的核心在于理解如何与const关键字一起使用，以确保遵循C++的常量正确性规则。通过获取常量对象或常量成员的地址，我们可以安全地访问这些数据，而不破坏它们的不变性。在类的设计中，正确重载取地址操作符的const版本是实现这一目标的关键。

## const 和 static 修饰对象/变量
![const](/关键字与限定符/const.md)

![static](/关键字与限定符/static.md)

## friend友元
在C++中，friend 关键字用于声明友元（Friend）函数或友元类，这是一种特殊机制，允许外部函数或指定的类访问当前类的私有（private）和保护（protected）成员，即使它们不是该类的成员函数或成员类。友元的设计突破了C++严格的封装原则，但有时是必要的，特别是在需要高效访问或操作类的内部数据时。下面是关于友元的详细解释：

### 友元函数
1. 声明：友元函数可以在类定义中声明，使用 friend 关键字，然后跟函数原型。
```cpp
class MyClass {
private:
    int secretData;
public:
    MyClass(int data) : secretData(data) {}
    
    friend void displaySecret(MyClass& obj);    // 友元函数
};
```

2. 定义：友元函数的定义与普通函数相同，不在类内部，但可以直接访问类的私有和保护成员。
```cpp
void displaySecret(MyClass& obj) {
    std::cout << "Secret Data: " << obj.secretData << std::endl;
}
```

3. 友元函数不是成员函数，即不能用const修饰 无this指针
4. 友元函数可以在类定义的任何地方声明，不受限定符限制
5. 如何理解友元声明  流插入流提取不能写在类内
```cpp
    friend istream& operator>>(istream& in, Date& d);
    friend ostream& operator<<(ostream& out, const Date& d);
```

#### 如何理解友元声明  流插入流提取不能写在类内
在C++中，流插入运算符（<<）和流提取运算符（>>）通常被重载为非成员函数，这是为了实现操作符的左右两边能够更加灵活地匹配不同类型。这也是为什么友元声明常用于这类操作符重载的原因之一。理解这一点，我们需要从几个角度来分析：

##### 非成员函数的原因
1. 灵活性和泛型性：将流操作符重载为非成员函数，允许左侧操作数（通常是流对象）的类型更为广泛，可以是基类指针或引用，这样就可以实现对派生类的多态支持。如果作为成员函数，则只能绑定到该类的实例上，限制了其灵活性。

2. 操作符对称性：流操作符通常期望是对称的，即既可以从左到右读取，也可以从右到左写入。如果将其中一个重载为成员函数，另一个作为非成员函数，可能会导致对称性丢失，且代码风格不一致。

##### 友元的作用
由于操作符重载函数通常需要访问类的私有或保护成员来读取或设置数据，但它们又是非成员函数，所以无法直接访问这些成员。此时，通过在类中声明这些重载函数为友元，就可以绕过访问控制，使它们能够访问类的私有和保护成员，同时保持重载函数的非成员特性。

##### 例子
考虑一个简单的类 Person 和对 std::ostream 的 << 重载为例：
```cpp
class Person {
private:
    std::string name;
    int age;
public:
    Person(const std::string& n, int a) : name(n), age(a) {}

    // 声明友元函数
    friend std::ostream& operator<<(std::ostream& os, const Person& p);
};

// 在类外定义友元函数
std::ostream& operator<<(std::ostream& os, const Person& p) {
    os << "Name: " << p.name << ", Age: " << p.age;
    return os;
}
```
在这个例子中，operator<< 作为一个非成员函数，需要访问 Person 类的私有成员 name 和 age。通过在 Person 类内部声明它为友元，即使它不是类的成员，也能够访问这些私有成员。

### 友元类
1. 声明：类似于友元函数，但这次是将整个类声明为友元，允许该友元类的所有实例访问当前类的私有和保护成员。
```cpp
class HelperClass;

class MyClass {
private:
    int data;
public:
    MyClass(int d) : data(d) {}
    friend class HelperClass; // 将HelperClass声明为友元类
};

class HelperClass {
public:
    void manipulateData(MyClass& mc) {
        mc.data *= 2; // 可以直接访问MyClass的私有成员
    }
};
```

#### 内部类
- 内部类不属于外部类
1. 外部类天生就是内部类的友元
2. 外部类可以访问内部类 反过来不行
3. sizeof(外部类) = 外部类，和内部类没有任何关系

### 注意点
友元函数注意事项：
1. 访问权限：友元函数虽然能访问类的私有和保护成员，但它自身并不属于该类的成员函数，因此不能直接使用.或->操作符访问对象成员，需要通过传入对象实例作为参数。
2. 声明位置：友元函数可以在类的公有、私有或保护部分声明，但通常放在公有部分以表明其意图。声明的位置不影响其访问权限。
3. 非成员函数：友元函数可以是独立的全局函数，也可以是另一个类的成员函数。如果是一个类的成员函数，则对该类的所有实例都授予友元访问权限。
4. 多文件编译：如果友元函数定义在另一个文件中，记得在使用前进行适当的声明或定义。

友元类注意事项：
1. 双向友元：友元关系不具有对称性。如果类A声明类B为友元，类B并不自动成为类A的友元，除非显式声明。
2. 访问权限：友元类的所有成员函数都可以访问另一个类的私有和保护成员，因此需要小心控制，避免不当访问导致的数据不一致或安全性问题。
3. 设计考量：尽量减少友元的使用，因为它们破坏了封装性，降低了类的独立性和代码的可维护性。只有在必要时才使用，比如为了性能优化或实现复杂的协作逻辑。
4. 编译单元：如果友元类定义在不同的编译单元，确保在使用前有正确的声明或包含相应的头文件。
5. 继承与友元关系：友元关系不被继承，即子类不自动继承父类的友元关系，也不能自动成为父类的友元。

通用注意事项
- 文档和注释：清楚地记录为什么需要友元关系，因为这可能不是显而易见的。良好的注释有助于维护人员理解设计决策。
- 替代方案：在使用友元之前，考虑是否有其他设计模式或技术可以达到同样的目的，例如提供公共的访问方法或使用委托模式。
- 代码审查：友元的使用应作为代码审查的重点，确保其必要性和正确性，避免过度使用导致的架构混乱。


### 特性与限制
- 非对称性：友元关系是非对称的，即A类声明B类为友元，不代表B类必须也将A类声明为友元。
- 不可继承：友元关系不能被继承，即子类不能自动成为父类的友元，反之亦然。
- 访问权限：友元具有完全访问权限，包括私有和保护成员，但不包括访问控制或构造函数、析构函数的特殊性质。
- 使用谨慎：友元破坏了封装性，应谨慎使用，仅在必要时作为优化或设计上的权衡。

### 应用场景
- 操作符重载：如重载 << 或 >> 流操作符，通常需要访问类的私有成员。
- 调试辅助类：提供专门的调试类访问私有成员，便于调试和分析。
- 紧密合作的类：两个类之间有紧密的协作关系，频繁且深入地需要访问彼此的内部状态。

总之，友元机制是C++为了在封装和效率、灵活性之间寻找平衡而引入的特殊设计，使用时应充分考虑其对封装性的破坏，并确保其必要性和合理性。

