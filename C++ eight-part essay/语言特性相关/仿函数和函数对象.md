# 仿函数/函数对象
在C++中，仿函数（Functors）和函数对象（Function Objects）这两个术语通常指的是同一个概念，即重载了()操作符的类的对象，使得这些对象可以像普通函数那样被调用。这种设计模式让类实例能够携带状态，并具有可定制的行为，相比普通的函数调用提供了更高的灵活性和功能性。

## 仿函数的特点
1. 类结构：仿函数是一个类，它通过重载函数调用操作符operator()来模拟函数的行为。
2. 携带状态：与普通函数不同，仿函数可以是带有成员变量的类实例，因此它们能够保存状态信息，这是普通函数所不具备的能力。
3. 重用性和多态性：由于仿函数是类的实例，因此它们可以作为参数传递给其他函数，存储在容器中，或作为算法的一部分，这为代码的复用和多态提供了便利。
4. 泛型编程：在C++ STL（标准模板库）中，仿函数常用于算法中，作为算法行为的自定义策略，如std::sort可以通过仿函数来指定排序规则。

## 示例：简单仿函数
```cpp
#include <iostream>

class Square Functor {
public:
    int operator()(int x) const {
        return x * x;
    }
};

int main() {
    Square Functor square;
    std::cout << "5 squared is: " << square(5) << std::endl; // 输出: 5 squared is: 25
    return 0;
}
```

## C++ STL中的仿函数
C++标准库中有许多预定义的仿函数类，位于``<functional>``头文件中，比如``std::plus, std::minus, std::bind``, 以及C++11引入的``lambda``表达式，它们也可以视为一种匿名的仿函数。

## 使用场景
- 算法自定义：在STL算法中，如std::sort、std::transform等，可以传入仿函数来自定义算法的行为。
- 策略模式：仿函数可以作为策略模式的一部分，根据不同的仿函数实现，改变程序的行为。
- 表达式模板：在一些高级应用中，仿函数结合模板元编程技术，可以实现表达式模板，进一步提升性能和代码灵活性。
