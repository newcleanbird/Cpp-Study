# 数据类型

## 声明 定义 初始化
- 声明是关于存在性的宣告，告诉编译器期待什么类型的标识符。
- 定义是实际创建变量或对象并分配内存的过程，通常伴随着初始化。
- 初始化是为变量或对象赋予初始状态的操作，可以在定义时一并完成。

### 声明（Declaration）
声明定义：是指告诉编译器变量的名称、类型以及可能的其他属性（如常量性、引用性等），但不一定分配内存或赋予初始值。

- 声明用于告诉编译器变量的**名称 和 类型，一般不分配内存**。这样就可以在之后的代码中使用它们。
- 变量的声明有两重含义:
  - 告诉编译器，这个名字已经匹配到一块内存上，下面的代码用到变量或者对象是在别的地方定义的。声明可以出现多次。
  - 告诉编译器，这个名字已经被预定了，别的地方再也不能用它来作为变量名或对象名。
- 声明可以出现在多个地方，但变量只应被定义一次。

示例：
```cpp
int age; // 声明了一个名为age的整形变量

extern int var; // 声明已经在其他地方有定义了，提示编译器遇到此变量时在其它模块中寻找其定义。
extern int ble = 10; // 表示定义了变量 ble，即使是 extern ，如果给变量赋值了，就是定义了。
typedef int INT; // 声明
struct Node;    // 声明
```

#### 声明的类型
1. 变量声明：
- 基本变量声明：例如 int num; 告诉编译器有一个名为num的整型变量存在。
- 指针、引用、数组等复合类型的声明：如 int* ptr;（指针）、int& ref = num;（引用）、int arr[10];（数组）。
- const 和 volatile限定符的使用：如 const int cNum = 10;（常量）、volatile int vNum;（易变变量）。
- 外部变量声明（使用extern）：extern int extVar; 表示变量extVar在别处定义。

2. 函数声明：
- 函数原型：如 int add(int a, int b); 告知编译器函数add接受两个整数参数并返回一个整数。
- 默认参数、重载函数的声明：函数可以通过不同参数列表或默认参数值来重载。
- inline函数和constexpr函数的声明：用于内联展开或编译时计算。

3. 类和结构体声明：
- 类定义本身就是一种声明，同时定义了数据成员和成员函数：class MyClass { ... };
- 前向声明：如 class ForwardDeclared; 仅声明类的存在，未给出细节，便于解决循环依赖问题。

4. 枚举声明：enum Color { Red, Green, Blue }; 定义了一个枚举类型Color。

5. 模板声明：template<typename T> T max(T a, T b); 声明了一个泛型最大值函数模板。

6. 命名空间声明：namespace MyNamespace { ... } 用于组织相关的类型、对象和函数。

7. 类型别名声明：typedef 或 using，如 typedef int Integer; 或 using Integer = int; 创建类型别名。

8. extern "C"声明：用于指示C++编译器按照C语言的链接规则处理函数或变量，如 extern "C" void func();。

9. 友元声明：在类定义中使用 friend 关键字声明其他类或函数为该类的友元，允许访问私有和保护成员。

10. using声明：在命名空间作用域或类作用域内，使用 using 引入特定名称，如 using std::cout;。


### 定义（Definition）

变量的定义用于为变量**分配存储空间，并可选地给出初始值，为变量指定初始值。**对于非静态局部变量和全局变量，定义也会执行初始化。

- 在一个程序中，变量**有且仅有一个定义**。

- 在 C/C++ 中，变量的声明和定义区别并不大，定义和声明往往是同时发生，变量定义时，会根据变量类型分配空间，

```c++
int age = 25; // 定义了一个名为age的整型变量，并初始化为25

int add(int x, int y) { return x + y; } // 函数的定义
```

#### 注意
- **不应该在头文件中定义变量**，因为一个头文件可能会被一个程序的许多源文件所包含。
- **全局变量或静态变量初始值为0**，**局部变量初始化为随机值**。

### 初始化（Initialization）
初始化是为变量赋予其初始值的过程。初始化可以在定义时进行，也可以在后续的代码中通过赋值操作完成，尽管某些情况下（如静态局部变量、全局变量、类的成员变量）编译器会自动执行默认初始化。

示例：
```cpp
int age = 30; // 初始化age变量为30
```
对于类的对象，初始化可能涉及到构造函数的调用：
```cpp
Person person("Alice", 30); // 初始化Person对象，通过构造函数传入初始值
```

### 变量声明和定义的区别

- 变量在使用前就要被定义或者声明。
- 一个变量可以在多个地方声明，但是只能在一个地方定义；(多声明，单定义)
- 变量的定义分配地址和存储空间，变量的声明不分配地址；
- 通常变量的定义和声明是同时发生的，注意：extern 变量类型 变量名 仅是声明。
- 很多时候一个变量只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量；

```c++
#include<bits/stdc++.h>
using namespace std;

extern int fun();    // 声明
int fun(){}  // 定义

int main()
{
    extern int A; // 声明A是一个外部已经定义了的外部变量
    // 声明外部变量时可以把类型去掉：extern A;
    extern int B = 100; // 定义，即使是extern
}
int A; // 是定义，定义了A是一个整型的全局变量(外部变量)
```

### 全局变量重定义问题

#### 原因

1. 外部链接性
   首先明确一点全局变量是具备 外部链接性的，何为外部连接性呢？外部链接性的变量通常简称为外部变量，作用域为整个文件。可以在文件中位于外部变量定义的后面的任意函数中使用它，因此也称为全局变量。
2. 头文件的作用
   当.c或者.cpp引用头文件的时候，无非是将头文件的内容拷贝入本.c或者.cpp。当我们在头文件中定义一个全局变量，而又在多个.c或者.cpp文件中引用它，就会引发全局变量重定义。话不多说看图：本图中B.cpp和C.cpp都引用了a.h等价于在B.cpp和C.cpp中都声明了全局变量。而全局变量的作用域是整个文件，故而出现了全局变量重定义的问题。

```c++
a.h
int A; // 定义全局变量

B.cpp
#include<a.h>
{
    a = 200;

}
C.cpp
#include<a.h>
{
    b = 150;
}
```

#### 解决办法

1. 可以引入 static 关键字，这个关键字的作用就是
   1. 全局变量范围只能限定在文件里，不会外联到整个模块和项目中。
   2. 变量只在源文件中有效。

> 尽量使用static关键字把变量定义限制于该源文件作用域，除非变量被设计成全局的。

2. 引入 inline关键字修饰函数
   inline 相当于在函数定义的地方，将函数展开，这样就可以避免函数符号在符号表中被多次找到。
3. 永远不要在.h文件中定义变量,这样容易导致重复定义错误。
4. 可以在头文件中声明一个变量，在用的时候包含这个头文件就声明了这个变量。
5. 头文件(.h)中 是对于该模块接口的声明，接口包括该模块提供给其它模块调用的外部函数及外部全局变量，对这些变量和函数都需在.h中文件中冠以extern关键字声明。

## 数据类型
1. 基本数据类型（Primitive Data Types）
   - 整型（Integer Types）：short, int, long, long long，以及它们的无符号版本unsigned short, unsigned int, unsigned long, unsigned long long。C++11还引入了char16_t, char32_t用于宽字符支持。
   - 字符型（Character Types）：char，宽字符类型wchar_t。
   - 布尔型（Boolean Type）：bool，取值为true或false。
   - 浮点型（Floating Point Types）：float, double, long double。

2. 复合数据类型（Compound Data Types）
   - 数组（Arrays）：固定大小的相同类型元素集合。
   - 结构体（Structures）：用户自定义的复合数据类型，可以包含不同类型的数据成员。
   - 联合体（Unions）：共享同一块内存区域的不同类型成员，一次只能有效使用其中一个成员。
   - 枚举（Enums）：定义一组命名的整数常量。

3. 特殊数据类型
   - 空类型（Void Type）：void，通常用于表示没有类型或者函数不返回值。
   - 指针类型（Pointer Types）：存储内存地址的变量，如int*, char**等。
   - 函数指针：指向函数的指针，可以调用对应的函数。
   - 成员指针：指向类成员变量或成员函数的指针。
  
4. 高级数据类型（Advanced or User-Defined Types）
   - 类（Classes）：支持封装、继承、多态的复杂数据类型。
   - 模板类型（Template Types）：泛型编程的基础，允许类型参数化，如vector<int>, list<double>。
   - 智能指针（Smart Pointers）：C++11引入，如unique_ptr, shared_ptr, 提供自动内存管理。
   - 类型别名（Type Aliases）：使用typedef或using关键字为现有类型定义新名称。
   - 枚举类（Enum Classes）：C++11引入，提供了更好的类型安全和作用域控制的枚举。



### 基本数据类型(Primitive Data Types)

#### 整形(Integral Types)
- short: 通常占用2字节，用于存储较小的整数值。
- int: 通常占用4字节，在大多数平台上是最常用的整数类型。
- long: 在32位系统上通常也是4字节，但64位系统上可能是8字节，具体取决于编译器。
- long long: 至少占用8字节，用于存储大整数。
- 以上每种整型都有对应的无符号（unsigned）版本，如unsigned int，能够存储两倍的正数范围，但不包括负数。

#### 字符型(Character Types)
- char: 通常占用1字节，用于存储单个字符，可以是ASCII码。
- wchar_t: 宽字符类型，用于存储更广泛的字符集，如Unicode字符，其大小依赖于实现。
- char16_t, char32_t: C++11引入，分别用于存储UTF-16和UTF-32编码的字符。

#### 浮点型(Floating Point Types)
- float: 单精度浮点数，通常占用4字节，适合不需要很高精度的浮点计算。
- double: 双精度浮点数，通常占用8字节，提供更高的精度，是默认的浮点类型。
- long double: 提供的精度至少与double相同，但具体大小和精度依编译器而定。

#### 布尔型(Boolean Type)
- bool: 只有两个可能的值：true和false，通常占用1字节，但具体实现可能有所不同。

#### 空类型(Void Type)
- void: 不代表任何特定类型，通常用于表示没有返回值的函数或泛型指针。

### 复合数据类型(Compound Types)
C++中的复合数据类型（Compound Types）是基于基本数据类型构建的，允许组合和操作多个数据项，从而形成更复杂的数据结构。复合数据类型使得程序能够处理现实世界中更为复杂的数据模型，提高代码的组织性和可读性。

#### 数组（Arrays）：
数组是一系列相同类型元素的集合，这些元素在内存中连续存储。数组的声明需要指定元素类型和数组大小。例如，int numbers[5]声明了一个可以存储5个整数的数组。

#### 字符串（String）：
C++处理字符串有两种方式：C风格字符串（字符数组以空字符\0结尾）和std::string类。std::string是C++标准库提供的一个类，提供了丰富的字符串操作方法，使用前需包含<string>头文件。

#### 指针（Pointer）：
指针是一种特殊的变量，存储的是另一个变量的内存地址。通过指针，可以间接访问和修改内存中的数据。指针类型定义时需指定其指向的变量类型，如int *ptrToInt。

#### 结构体（Structure）：
结构体是一种复合数据类型，允许你定义自己的数据类型，组合不同基本类型或复合类型的成员。例如，struct Person {std::string name; int age;}定义了一个包含姓名和年龄的结构体类型。

#### 联合体（Union）：
联合体也是一种复合类型，但它所有的成员共享同一块内存区域。任何时候，联合体中只有一个成员的值是有效的。这在需要节省内存或实现类型转换的场景中很有用。

#### 枚举（Enumeration）：
枚举类型允许定义一系列命名的常量，这些常量代表整数值。例如，enum Color {Red, Green, Blue};定义了一个颜色枚举，其中Red、Green、Blue分别对应整数值0、1、2。

#### 类（Class）：
类是C++面向对象编程的核心，它不仅包含了数据成员（变量），还包含了成员函数（方法），支持封装、继承和多态等特性。类的定义允许创建用户自定义的复合类型，用于构建复杂的对象模型。

#### 模板（Template）：
模板不是直接的数据类型，但它们允许创建泛型代码，可以处理多种数据类型。模板允许你定义函数或类，在实例化时才指定具体的数据类型，提供了极大的灵活性和代码复用性。

### 特殊数据类型
#### void类型:
- void类型是一个独一无二的数据类型，它不代表任何具体的数据值。它主要用于函数返回类型，表明该函数不返回任何值。同时，void*是一种指针类型，可以指向任何类型的数据，但使用时需要强制类型转换来明确目标类型，以确保安全。

#### nullptr（空指针常量）:
- 自C++11起，nullptr被引入作为一种特殊类型的字面量，用于表示空指针。它比传统的NULL宏更安全，因为它有自己的类型std::nullptr_t，可以避免类型转换时的歧义，减少潜在的错误。

#### auto类型推导:
- 虽然auto不是一个数据类型本身，但它是一种类型说明符，能够让编译器自动推导出变量的类型。这在处理复杂类型或者避免冗余时非常有用，比如在使用迭代器或返回类型复杂的表达式时。

#### decltype类型推导:
- decltype关键字用于获取一个表达式的类型。它不是直接定义变量的类型，而是帮助获取并使用其它地方已存在的类型，常用于泛型编程和模板元编程中。

#### 类型别名（typedef和using）:
- typedef和C++11引入的using关键字允许为现有的类型创建一个新的名字，即类型别名。这对于简化复杂类型名、提高代码可读性及创建平台无关的类型定义非常有帮助。

#### 枚举类（enum class）:
- 从C++11开始，枚举类（enum class）提供了一种更安全、具有更好类型安全性的枚举类型。与传统枚举相比，枚举类的成员默认具有私有作用域，减少了命名冲突的风险。

#### 类型特征（type traits）:
- 标准模板库(STL)中的类型特征是一组模板，用于检查或修改类型属性。例如，std::is_integral<T>可以检查类型T是否为整数类型，这类特征广泛应用于泛型编程中，以实现条件编译和类型安全的代码。

### 高级数据类型(Advanced or User-Defined Types)
#### 类（Class）:
类是C++面向对象编程的核心，允许用户定义自己的数据类型。类可以包含数据成员（变量）和成员函数（方法），支持封装、继承和多态等面向对象的特性。类的使用可以更好地模拟现实世界的实体和行为，提升代码的组织性和重用性。

#### 枚举类（Enum Class 或 Enum Struct）:
从C++11开始，枚举类（enum class 或 enum struct）提供了一种更安全的枚举类型，其成员默认具有限定作用域，减少了命名空间污染。枚举类提高了类型安全性，因为每个枚举值都有其所属的枚举类型作为上下文。

#### 模板（Template）:
模板是C++泛型编程的关键特性，允许程序员编写独立于类型的代码。模板可以用来创建函数模板和类模板，使得代码能够适用于多种数据类型，提高了代码的通用性和灵活性。例如，std::vector<T>就是一个典型的类模板，可以创建容纳任意类型的动态数组。

#### 智能指针（Smart Pointers）:
智能指针是C++标准库提供的高级指针类型，如std::unique_ptr、std::shared_ptr和std::weak_ptr，它们自动管理内存，防止内存泄漏和悬挂指针问题。智能指针通过封装原始指针，提供了所有权管理和自动销毁机制。

#### STL容器（Standard Template Library Containers）:
STL容器如std::vector、std::list、std::map等，是预定义的数据结构，提供了高效的内存管理和数据访问接口。它们是模板类，可以存储任意类型的数据，并且内置了迭代器、算法等支持，极大地简化了常见的数据结构操作。

#### 联合（Union）:
虽然联合属于基本数据类型范畴，但其在高级编程中的用途使其值得一提。联合允许在相同的内存位置存储不同类型的变量，但一次只能有效使用其中一个成员。这在需要节省空间或实现类型转换时很有用，不过使用时需要注意数据一致性问题。

#### 类型别名（Type Alias）:
使用using或传统的typedef关键字定义类型别名，可以为复杂类型或频繁使用的类型提供简短易记的名字，提高代码的可读性和维护性。在现代C++中，using语法更加灵活，支持模板参数和更复杂的类型定义。

### 其他新类型
#### initializer_list
- initializer_list是一个标准库类型，是一个代表数组的轻量级包装器，用于存储同一类型的常量对象的列表。主要用于方便地初始化聚合类型（如数组、向量）和在构造函数中接受不定数量的同类型参数。支持作为函数参数或类成员初始化列表使用，用于传递一个初始化元素列表。
[initializer_list](/数据类型/initializer_list.md)

## 强制类型转换

### C风格的强制类型转换

C风格的强制类型转换很容易理解，不管什么类型都可以直接进行转换，使用格式如下：

```c++
Type b = (Type)a;
```

当然，C++也是支持C风格的强制类型转换的，但是C风格的强制类型转换可能会带来一些隐患，出现一些难以察觉的问题，所以C++又推出了四种新的强制类型转换来替代C风格的强制类型转换，降低使用风险。

### C++风格的强制类型转换

在C++中新增了四个关键字 ``static_cast``、``const_cast``、``reinterpret_cast``和 ``dynamic_cast``，用于支持C++风格的强制类型转换。这几个看起来有点像类模板，但事实上他们是正儿八经的关键字。C++风格的强制类型转换的好处是它们能更清晰的表明它们要干什么，程序员只要扫一眼这样的代码，就能立即知道一个强制转换的目的，并且在多态场景也只能使用C++风格的强制类型转换。

#### static_cast

``static_cast``是最常用的C++风格的强制类型转换，主要是为了执行那些较为合理的强制类型转换，使用格式如下：

```cpp
static_cast<type_id>(expression);
```

因为 ``static_cast``的使用范围比较广，而且限制也比较多，所以下面分小节对各个场景进行分析

1. 用于基本内置数据类型之间的转换
   ``static_cast``可以用于基本内置数据类型之间的转换，比如把 ``char``转成 ``float``、``double``转换成 ``long``等，这种内置类型之间的转换往往可以由隐式转换自动执行，而不需要人工特地去执行强制类型转换。由于转换结果可能存在截断性，这种转换的安全性要由开发人员来保证（一般不会出现严重程序运行错误，但是可能会出现逻辑错误），编译器可能会适当打印警告信息。示例如下：

```c++
#include <iostream>

int main(int argc, char* argv[])
{
    char type_char = 'A';
    float type_float = type_char; // 隐式转换也可以
    float type_float_cast = static_cast<float>(type_char); // 显式地使用static_cast进行强制类型转换

    double type_double = 1.23;
    long type_long = type_double; // 隐式转换也可以
    long type_long_cast = static_cast<long>(type_double); // 显式地使用static_cast进行强制类型转换
}
```

2. 用于指针之间的转换
   ``static_cast``可以用于指针之间的转换，这种转换类型检查非常严格，不同类型的指针是直接不给转的，除非使用 ``void*``作为中间参数，我们知道隐式转换下 ``void*``类型是无法直接转换为其它类型指针的，这时候就需要借助 ``static_cast``来转换了。示例如下：

```cpp
#include <iostream>

int main(int argc, char* argv[])
{
    int type_int = 10;
    float* float_ptr1 = &type_int; // int* -> float* 隐式转换无效
    float* float_ptr2 = static_cast<float*>(&type_int); // int* -> float* 使用static_cast转换无效
    char* char_ptr1 = &type_int; // int* -> char* 隐式转换无效
    char* char_ptr2 = static_cast<char*>(&type_int); // int* -> char* 使用static_cast转换无效

    void* void_ptr = &type_int; // 任何指针都可以隐式转换为void*
    float* float_ptr3 = void_ptr; // void* -> float* 隐式转换无效
    float* float_ptr4 = static_cast<float*>(void_ptr); // void* -> float* 使用static_cast转换成功
    char* char_ptr3 = void_ptr; // void* -> char* 隐式
  
    转换无效
    char* char_ptr4 = static_cast<char*>(void_ptr); // void* -> char* 使用static_cast转换成功
}
借助void*和static_cast，将一个不同类型的指针指向不同类型的对象。
任何类型 -> void* -> static_cast<类型*>
```

> 补充说明：static_cast是直接不允许不同类型的"引用"进行转换的，因为没有void类型引用可以作为中间介质，这点和指针是有相当大区别的

3. 不能转换掉expression的const或volitale属性
   static_cast不能转换掉expression的const或volitale属性。示例如下：

```cpp
#include <iostream>

int main(int argc, char* argv[])
{
    int temp = 10;

    const int* a_const_ptr = &temp;
    int* b_const_ptr = static_cast<int*>(a_const_ptr); // const int* -> int* 无效

    const int a_const_ref = 10;
    int& b_const_ref = static_cast<int&>(a_const_ref); // const int& -> int& 无效

    volatile int* a_vol_ptr = &temp;
    int* b_vol_ptr = static_cast<int*>(a_vol_ptr); // volatile int* -> int* 无效

    volatile int a_vol_ref = 10;
    int& b_vol_ref = static_cast<int&>(a_vol_ref); // volatile int& -> int& 无效
}
```

4. 用于类实例的之间转换

```cpp
#include <iostream>

class A
{
public:
    int a;
};

class B
{
public:
    int b;
};

class C : public A, public B // C公有继承A 和 B
{
public:
    int c;
};

int main(int argc, char* argv[])
{
    C c;
    A a = static_cast<A>(c); // 上行转换正常,将派生类转化为基类
    B b = static_cast<B>(c); // 上行转换正常

    C c_a = static_cast<C>(a); // 下行转换无效,将基类转化为派生类
    C c_b = static_cast<C>(b); // 下行转换无效
}
```

从测试程序中可以看到如果对类实例使用static_cast进行转换，static_cast是会进行类型判断的，对于上行转换来说这个过程就是正常的（其实任何合法的上行转换都可以直接由隐式转换来完成，而不需要手工去强制类型转换），但是下行转换则不行，static_cast认为下行转换等同于两个无关联的类进行转换，会报错。但是这个错误是有解决方法的，我们从报错信息中可以看到当static_cast转换失败时，会使用expression作为传入参数来调用type_id的构造函数，所以我们可以把类C改成以下形式，上面的示例即可编译通过

```cpp
class C : public A, public B
{
public:
    C()
    {
    }

    C(const A& v)   // 在类C中构造一个使用对象A为参数的构造函数
    {
        a = v.a;
    }

    C(const B& v)   // 在类C中构造一个使用对象B为参数的构造函数
    {
        b = v.b;
    }

    int c;
};
```

综上，我们可以得出使用 ``static_cast``对类实例进行强制类型转换时有以下特点：
(1)进行上行转换是完全安全合法的，当然这个过程由隐式转换来完成也是合法的。
(2)进行下行转换时，static_cast会认为两个类无关联，这种转换不合法。如果此时硬要转换的话，比如类A->类B（这两个类可以无任何关系，因为实例下行转换static_cast就是认为他们没关联），可以在B中添加一个使用类A进行构造的构造函数，比如B(const A&)，这样就可以正常使用static_cast来进行类A->类B的操作了
5. 用于没有多态的类实例指针或引用之间的转换
进行上行转换的示例如下：

```cpp
#include <iostream>

class A
{
public:
    int a;
};

class B
{
public:
    int b;
};

class C : public A, public B
{
public:
    int c;
};

int main(int argc, char* argv[])
{
    C c;

    A* a_ptr = static_cast<A*>(&c); // 上行指针转换正常
    B* b_ptr = static_cast<B*>(&c); // 上行指针转换正常
    A& a_ref = static_cast<A&>(c);  // 上行引用转换正常
    B& b_ref = static_cast<B&>(c);  // 上行引用转换正常
}
```

可以看到上行转换都是正常的，转换过程中不会出现任何显性和隐性错误，下面来看一下下行转换的示例：

```cpp
int main(int argc, char* argv[])
{
    C c;
    A* a_ptr = static_cast<A*>(&c);
    B* b_ptr = static_cast<B*>(&c);
    A& a_ref = static_cast<A&>(c);
    B& b_ref = static_cast<B&>(c);

    C* c_ptra = static_cast<C*>(a_ptr); // 下行指针转换正常
    C* c_ptrb = static_cast<C*>(b_ptr); // 下行指针转换正常
    C& c_refa = static_cast<C&>(a_ref); // 下行引用转换正常
    C& c_refb = static_cast<C&>(b_ref); // 下行引用转换正常

    A* a_ptr_fail = static_cast<A*>(b_ptr); // B* -> A*，无关联的两个类型，无效
}
```

从上面的例子可以看到，下行转换也是正常的，并且static_cast也会拒绝掉两个无关联类之间的转换？？？这和书中说的不一样啊，不是说static_cast下行转换不安全吗？别急，上面的例子是片面的，各位看一下下面的代码就知道了

```cpp
int main(int argc, char* argv[])
{
    A a;
    B b;

    // 以下都能转换成功，说明static_cast根本就没有安全检查，只看到有继承关系就给转换了
    C* c_ptra = static_cast<C*>(&a);
    C* c_ptrb = static_cast<C*>(&b);
    C& c_refa = static_cast<C&>(a);
    C& c_refb = static_cast<C&>(b);
}
```

综上，我们可以得出使用static_cast对没有多态的类实例指针或引用进行强制类型转换时有以下特点：
(1)进行上行转换（派生类指针->基类指针、派生类引用->基类引用）是完全安全的，没有任何问题，当然这个过程由隐式转换来完成也是合法的
(2)进行下行转换（基类指针->派生类指针、基类引用->派生类引用）由于缺乏安全检查，所以是有问题的，要尽量避免这种用法。
(3)如果两个类无继承关系，则使用static_cast进行转换时会失败，但是这种情况下static_cast会显性地展示出错误信息，是安全的。

6. 用于具有多态的类实例指针或引用之间的转换
   进行上行转换的示例如下：

```cpp
#include <iostream>

class A
{
public:
    virtual void print()    // 虚函数print()
    {
        std::cout << "A" << std::endl;
    }
};

class B
{
public:
    virtual void print()    // 虚函数print()
    {
        std::cout << "B" << std::endl;
    }
};

class C : public A, public B    // 类c公开继承A和B
{
public:
    virtual void print() override   // 
    {
        std::cout << "C" << std::endl;
    }
};

int main(int argc, char* argv[])
{
    C c;

    A* a_ptr = static_cast<A*>(&c); // 上行指针转换正常
    B* b_ptr = static_cast<B*>(&c); // 上行指针转换正常
    a_ptr->print();                 // 输出C，符合多态的要求
    b_ptr->print();                 // 输出C，符合多态的要求

    A& a_ref = static_cast<A&>(c); // 上行引用转换正常
    B& b_ref = static_cast<B&>(c); // 上行引用转换正常
    a_ref.print();                 // 输出C，符合多态的要求
    b_ref.print();                 // 输出C，符合多态的要求
}
```

可以看到上行转换都是正常的，转换过程中不会出现任何显性和隐性错误，下面来看一下正常的下行转换的示例：

```cpp
int main(int argc, char* argv[])
{
    C c;
    A* a_ptr = static_cast<A*>(&c);
    B* b_ptr = static_cast<B*>(&c);
    A& a_ref = static_cast<A&>(c);
    B& b_ref = static_cast<B&>(c);

    C* c_ptra = static_cast<C*>(a_ptr); // 下行指针转换正常
    C* c_ptrb = static_cast<C*>(b_ptr); // 下行指针转换正常
    c_ptra->print(); // 输出C，符合多态的要求
    c_ptrb->print(); // 输出C，符合多态的要求

    C& c_refa = static_cast<C&>(a_ref); // 下行引用转换正常
    C& c_refb = static_cast<C&>(b_ref); // 下行引用转换正常
    c_refa.print(); // 输出C，符合多态的要求
    c_refb.print(); // 输出C，符合多态的要求
}
```

```cpp
int main(int argc, char* argv[])
{
    A a;
    B b;

    C* c_ptra = static_cast<C*>(&a);    // 指针向下转换
    C* c_ptrb = static_cast<C*>(&b);    // 指针向下转换
    c_ptra->print(); // 正常输出A
    c_ptrb->print(); // 段错误

    C& c_refa = static_cast<C&>(a);     // 类型向下转换
    C& c_refb = static_cast<C&>(b);     // 类型向下转换
    c_refa.print(); // 正常输出A
    c_refb.print(); // 段错误
}
```

上面这个例子中的下行转换是错误的，但是通过c_ptra可以正常调用类A的print()方法打印出字母A来，使用c_ptrb就直接段错误了，原因是类A是第一个被继承的，类B是第二个被继承的，也就是在类C中，第一个虚表指针指向的就是类A的虚表，第二个虚表指针指向的就是类B的虚表。在上面的例子那样进行错误地转换时，由于类A被继承之后它位置的特殊性导致可以使用c_ptra正确地调用类A的print()方法，而类B则不行，可能这有点难理解，下面给大家看张图就明白了，如图2-1所示：
![类C的内存分布和虚表](04类C的内存分布和虚表.png)
从图2-1中可以看出，对于类C来说，它始终调用着_vptr.A指向的print()方法，当我们使用纯类B类型进行下行转换时，根本就没有这一块的数据（这个转换是不完整的、不安全的），所以就会出现段错误了。当然，使用纯类A类型进行下行转换也是不完整、不安全的，只不过位置刚好才不会出现段错误而已。综合分析上面的代码是完全错误的，一定要杜绝写出这种垃圾代码。

综上，我们可以得出使用static_cast对具有多态的类实例指针或引用进行强制类型转换时有以下特点：
(1)进行上行转换（派生类指针->基类指针、派生类引用->基类引用）是完全安全的，没有任何问题，当然这个过程由隐式转换来完成也是合法的。
(2)进行下行转换（基类指针->派生类指针、基类引用->派生类引用）由于缺乏安全检查，所以是有问题的，并且因为具有多态的类往往具有特殊的用法，所以在这种情况下产生的后果比前面没有多态情况下的要更严重，要尽量避免这种用法。

7. 小结：
   通过上面的介绍，我们可以很直观地看到static_cast相比C风格的强制类型转换要安全很多，有很大程度上的类型安全检查。本节我们所有的例子都可以使用C风格的强制类型转换去做，但是转出来的结果有可能会错到天际去，并且编译器不会给你任何报错信息。。。同时我们也要认识到static_cast也是有明显缺点的，那就是无法消除const和volatile属性、无法直接对两个不同类型的指针或引用进行转换和下行转换无类型安全检查等，不过没关系，其它三个强制类型转换的关键字刚好能弥补static_cast的这些缺点。

#### const_cast--指针和引用

``const_cast``的作用是去除掉指向常量对象的指针或引用的常量(只读)性 ``const``或 ``volitale``属性，前面介绍 ``static_cast``的时候我们知道 ``static_cast``是不具备这种功能的。使用格式如下：

```cpp
const_cast<type_id>(expression);
```

> 注意事项：const_cast不是用于去除变量的常量性，而是去除指向常量对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用，并且const_cast不支持不同类型指针或引用之间的转换，比如说float*转换成int*是不允许的，直白一点说就是type_id和expression要基本类型保持一致，相差的话只能差const或volatile属性。

先来看一个错误的使用示例：

```cpp
#include <iostream>

int main(int argc, char* argv[])
{
    int type_int = 100;
    float type_float = const_cast<float>(type_int);        // 错误，const_cast只能转换引用或者指针
    float* type_float_ptr = const_cast<float*>(&type_int); // 错误，从int* -> float* 无效
    float& type_float_ref = const_cast<float&>(type_int);  // 错误，从int& -> float& 无效
}
```

再来看一个不太正确的使用示例：

```cpp
#include <iostream>

int main(int argc, char* argv[])
{
    const int type_const_int = 100;
    int* type_const_int_ptr = const_cast<int*>(&type_const_int); // 转换正确
    int& type_const_int_ref = const_cast<int&>(type_const_int);  // 转换正确
  
    *type_const_int_ptr = 10;
    std::cout << *type_const_int_ptr << std::endl; // 输出10
    std::cout << type_const_int << std::endl;      // 输出100，没有改变

    type_const_int_ref = 20;
    std::cout << type_const_int_ref << std::endl; // 输出20
    std::cout << type_const_int << std::endl;     // 输出100，没有改变

    // 以下三个输出结果一致，说明const_cast确实只是去除了一些属性，并没有重新搞快内存把需要转换的变量给复制过去
    std::cout << "&type_const_int:\t" << &type_const_int << std::endl;
    std::cout << "type_const_int_ptr:\t" << type_const_int_ptr << std::endl;
    std::cout << "&type_const_int_ref:\t" << &type_const_int_ref << std::endl;
}
```

在上面这个例子中，转换是成功了，但是type_const_int的常量性并没有被改变，这是因为const_cast并没有办法把变量的常量性去除，而且比较有意思的是我们可以看到type_const_int对应地址的内容确实被改变了，但是type_const_int的值却并没有被改变，这是好事，因为从一开始我们把它定义为常量类型时这个值就不应该再被改变了。至于后面使用type_const_int_ptr和type_const_int_ref试图去改变type_const_int的值，这是很危险的做法，不同编译器可能会有不同的处理，是有可能出现严重错误的，要杜绝这种用法。

```cpp
常量折叠:

由于type_const_int被const修饰，并被初始化为100，编译器在编译优化过程中发现type_const_int的值是可预知的，并被const修饰。之后所有使用type_const_int变量的地方，都可以用预知值替换。因此，编译阶段，cout << "type_const_int =" << type_const_int <<endl;中的type_const_int变量就直接被100替换了。所以后面对type_const_int变量值的修改，其内存中值是被改变了的，但编译阶段提前被替换的type_const_int始终为数值100。

const修饰的变量，其本质还是变量，还是可以修改的。

那么我们怎么才能防止这么常量折叠呢？

一种方法就是，定义为非const变量。

另一种方法就是，加volatile进行修饰。（感觉有点多此一举了，既然定义为const，我们的目的就是不随意修改它）。
```

从这里看起来const_cast好像有点鸡肋。。。但是事实上不是这样的，在某些场景下const_cast还是挺好用的，比如下面这个例子：

```cpp
#include <iostream>

void fun(const int& v)
{
    int& type_int_ref = const_cast<int&>(v);
    type_int_ref = 10;
}

int main(int argc, char* argv[])
{
    int type_int = 100;

    fun(type_int);
    std::cout << type_int << std::endl; // 输出10，改变了
}
```

上面的例子比较粗糙，但是大致上也就是这么个用法了。如果一个变量本来就不具备const属性，但是在传递过程中被附加了const属性，这时候使用const_cast就能完美清除掉后面附加的那个const属性了。
当然，因为const_cast的这种特殊性，它的应用范围是远不如static_cast广泛的，但是在标准库中还是能找到一些使用const_cast的例子的，比如“著名的”std::addressof在源码实现中就有借助const_cast作为中间层来消除参数的const和volatile属性，具体大家可以看一下这篇文章《C++11的std::addressof源码解析》。

#### reinterpret_cast

- 为了让编译器强制接受static_cast不允许的类型转换

reinterpret_cast意为“重新解释”，它是C++中最接近于C风格强制类型转换的一个关键字。它让程序员能够将一种对象类型转换为另一种，不管它们是否相关。使用格式如下：
reinterpret_cast<type_id>(expression);

1. 注意事项如下：
   1. type-id和expression中必须有一个是指针或引用类型（可以两个都是指针或引用，指针引用在一定场景下可以混用，但是建议不要这样做，编译器也会给出相应的警告）。
   2. reinterpret_cast的第一种用途是改变指针或引用的类型
   3. reinterpret_cast的第二种用途是将指针或引用转换为一个整型，这个整型必须与当前系统指针占的字节数一致
   4. reinterpret_cast的第三种用途是将一个整型转换为指针或引用类型
   5. 可以先使用reinterpret_cast把一个指针转换成一个整数，再把该整数转换成原类型的指针，还可以得到原先的指针值（由于这个过程中type-id和expression始终有一个参数是整形，所以另一个必须是指针或引用，并且整型所占字节数必须与当前系统环境下指针占的字节数一致）
   6. 使用reinterpret_cast强制转换过程仅仅只是比特位的拷贝，和C风格极其相似（但是reinterpret_cast不是全能转换，详见第1点），实际上reinterpret_cast的出现就是为了让编译器强制接受static_cast不允许的类型转换，因此使用的时候要谨而慎之
   7. reinterpret_cast同样也不能转换掉expression的const或volitale属性。
      先来看一个错误的使用示例：

```c++
#include <iostream>

class A
{
public:
    int a;
};

class B
{
public:
    int b;
};

int main(int argc, char* argv[])
{
    float type_float = 10.1;
    int type_int = reinterpret_cast<int>(type_float); // 出错，type-id和expression中必须有一个是指针或者引用（注意事项第1点）
    char type_char = reinterpret_cast<char>(&type_float); // 出错，我的是64位系统，这里type-id只能是long类型（注意事项第3点）
    double* type_double_ptr = reinterpret_cast<double*>(type_float); // 出错，这里expression只能是整型（注意事项第4点）

    A a;
    B b;
    long type_long = reinterpret_cast<long>(a); // 出错，type-id和expression中必须有一个是指针或者引用（注意事项第1点）
    B b1 = reinterpret_cast<B>(a); // 出错，type-id和expression中必须有一个是指针或者引用（注意事项第1点）
    A a1 = reinterpret_cast<A>(&b); // 出错，B* -> A不允许，我的是64位系统，type-id只能是long（注意事项第3点）
    A* a_ptr = reinterpret_cast<A*>(b); // 出错，这里expression只能是整型（注意事项第4点）
}
```

下面再来看正确的使用示例：

```cpp
#include <iostream>

class A
{
public:
    int a;
};

class B
{
public:
    int b;
};

int main(int argc, char* argv[])
{
    float type_float = 10.1;

    long type_long = reinterpret_cast<long>(&type_float); // 正确，float* -> long（注意事项第3点）

    float* type_float_ptr = reinterpret_cast<float*>(type_long); // 正确，long -> float*（注意事项第4点）
    std::cout << *type_float_ptr << std::endl; // 正确，仍然输出10.1（注意事项第5点）

    long* type_long_ptr = reinterpret_cast<long*>(&type_float); // 正确，float* -> long*（注意事项第1点）
  
    char type_char = 'A';
    double& type_double_ptr = reinterpret_cast<double&>(type_char); // 正确，char -> double&（注意事项第4点）

    A a;
    B b;
    long a_long = reinterpret_cast<long>(&a); // 正确，A* -> long（注意事项第3点）
    A* a_ptr1 = reinterpret_cast<A*>(type_long); // 正确，long -> A*（注意事项第4点）
    A* a_ptr2 = reinterpret_cast<A*>(&b); // 正确，B* -> A*（注意事项第1点）
}
```

程序中写的比较清楚了，大家配合前面的注意事项去看就行了，很容易就可以看懂了。reinterpret_cast的一个典型使用也是标准库的std::addressof，具体大家可以看一下这篇文章《C++11的std::addressof源码解析》。

#### dynamic_cast

``dynamic_cast``是本文讲的最后一个C++风格强制类型转换了，也是最特殊的一个，前面三种都是编译时完成的，而 ``dynamic_cast``是运行时处理的，使用格式如下：

```c++
dynamic_cast<type_id>(expression);
```

注意事项如下：

1. dynamic_cast是运行时处理的，运行时会进行类型检查（这点和static_cast差异较大）
2. dynamic_cast不能用于内置基本数据类型的强制转换，并且dynamic_cast只能对指针或引用进行强制转换
3. dynamic_cast如果转换成功的话返回的是指向类的指针或引用，转换失败的话则会返回nullptr
4. 使用dynamic_cast进行上行转换时，与static_cast的效果是完全一样的
5. 使用dynamic_cast进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。并且这种情况下dynamic_cast会要求进行转换的类必须具有多态性（即具有虚表，直白来说就是有虚函数或虚继承的类），否则编译不通过
6. 需要有虚表的原因：类中存在虚表，就说明它有想要让基类指针或引用指向派生类对象的情况，dynamic_cast认为此时转换才有意义（事实也确实如此）。而且dynamic_cast运行时的类型检查需要有运行时类型信息，这个信息是存储在类的虚表中的
7. 在C++中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。dynamic_cast则可以在运行期对可能产生问题的类型转换进行测试

先来看一个错误的使用示例：

```cpp
#include <iostream>

class A
{
public:
    void print()
    {
        std::cout << "A" << std::endl;
    }
};

class B
{
public:
    void print()
    {
        std::cout << "B" << std::endl;
    }
};

class C : public A, public B
{
public:
    void print()
    {
        std::cout << "C" << std::endl;
    }
};

int main(int argc, char* argv[])
{
    C c;
    A* a_ptr = dynamic_cast<A*>(&c); // 成功，上行转换没有任何要求（注意事项第4点）
    B* b_ptr = dynamic_cast<B*>(&c); // 成功，上行转换没有任何要求（注意事项第4点）

    A a = dynamic_cast<A>(c); // 错误，dynamic_cast无法用于转换类实例（注意事项第2点）

    C* c_ptra = dynamic_cast<C*>(a_ptr); // 错误，类C不具备多态，无法进行下行转换（注意事项第5点）
    C* c_ptrb = dynamic_cast<C*>(b_ptr); // 错误，类C不具备多态，无法进行下行转换（注意事项第5点）
}
```

从上面的例子中可以看到，dynamic_cast是无法对实例进行转换的，并且dynamic_cast进行下行转换时是需要对应的类拥有多态性的，这两点和static_cast是有区别，当然这些不是最重要的区别，下面我们再来看一个例子：

```c++
#include <iostream>

class A
{
public:
    virtual void print()
    {
        std::cout << "A" << std::endl;
    }
};

class B
{
public:
    virtual void print()
    {
        std::cout << "B" << std::endl;
    }
};

class C : public A, public B
{
public:
    virtual void print()
    {
        std::cout << "C" << std::endl;
    }
};

int main(int argc, char* argv[])
{
    C c;

    // 第一组
    A* a_ptr = dynamic_cast<A*>(&c);
    B* b_ptr = dynamic_cast<B*>(&c);
    C* c_ptra = dynamic_cast<C*>(a_ptr); // 成功，类C具备多态性，可以使用dynamic_cast进行下行转换
    C* c_ptrb = dynamic_cast<C*>(b_ptr); // 成功，类C具备多态性，可以使用dynamic_cast进行下行转换
    // 以下输出内容一致
    std::cout << &c << std::endl;
    std::cout << c_ptra << std::endl;
    std::cout << c_ptra << std::endl;

    // 第二组
    A a;
    B b;
    C* c_ptra1 = dynamic_cast<C*>(&a); // 编译正常（好的编译器会给你个警告），转换结果为nullptr，说明转换失败
    C* c_ptrb1 = dynamic_cast<C*>(&b); // 编译正常（好的编译器会给你个警告），转换结果为nullptr，说明转换失败
    // 以下输出内容一致，都是0，说明c_ptra1和c_ptrb1都是nullptr
    std::cout << c_ptra1 << std::endl;
    std::cout << c_ptrb1 << std::endl;
}
```

从上面的例子中可以看出以下几点信息：

- 对于第一组来说，因为这一组的下行转换是安全的（因为a_ptr和b_ptr本来就是类C的指针类型转换过去的），所以对于这种情况static_cast和dynamic_cast是一样的，都可以正常使用。
- 对于第二组来说，这个是一个错误使用的示例，我们之前也有用static_cast做过同样的实验（忘了的话可以翻回去2.1.3小节看一下），当时使用static_cast进行这种错误的下行转换时是一点问题没有的，可以转换成功，甚至可以使用一下（当然这是极其糟糕的行为），而现在使用dynamic_cast来转换则不同了，虽然编译也可以通过，但是它返回的结果是一个空指针，这就可以在运行时提示我们转换不合法了。

#### 总结

本文讲解了C++中存在的五种强制类型转换，其中C风格的只是一笔带过而已，重点讲的是C++中新增的四种强制类型转换，文中也有对它们各自的优点和缺点进行解析。整体来说C++增加的这几种强制类型转换相比C风格的更加安全，所以在编写C++代码时还是尽量使用它们替换C风格的强制类型转换吧。

## 列表初始化
列表初始化是一种 C++11 中引入的新特性，可用来初始化各种类型的对象，包括数组、结构体、类以及容器等。具体来说，列表初始化使用花括号 {} 将一组值括起来，用逗号分隔各个元素，形成一个初始化列表；

[列表初始化](/数据类型/列表初始化.md)