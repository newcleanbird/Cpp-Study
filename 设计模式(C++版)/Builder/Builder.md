# Builder 构建器
构建器模式（Builder Pattern）是一种创建型设计模式，其目的是将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。该模式尤其适用于那些构造过程复杂，有多个可选参数或者需要遵循特定构建步骤的对象创建场景。

## 动机（Motivation）
+ 在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这
个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。
+ 如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？


## 模式定义
将一个复杂对象的构建与其表示相分离，使得同样的构建过程(稳定)可以创建不同的表示(变化)。
——《设计模式》GoF


## 要点总结
+ Builder 模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。
+ 变化点在哪里，封装哪里—— Builder模式主要在于应对“复杂对象各个部分”的频繁需求变动。其缺点在于难以应对“分步骤构建算法”的需求变动。
+ 在Builder模式中，要注意不同语言中构造器内调用虚函数的差别(C++(构造函数中不可以调用虚函数) vs. C#)。

## 详解构建器模式
### 实现机制
1. 产品类（Product）：定义复杂对象的接口或抽象类，包含所有必要的属性，但不涉及构造细节。

2. 构建器接口（Builder）：定义一个创建产品对象的接口，但不提供具体实现。一般包含设置各个部分的方法。

3. 具体构建器（Concrete Builder）：实现构建器接口，具体负责创建并组装产品对象的各个部分。

4. 导演类（Director）：负责指导构建过程，通常包含一个构建产品的步骤方法，调用具体构建器的接口方法来创建产品。

### 优点
1. 封装性：构建过程的复杂性被封装在构建器类中，使得产品类和客户端代码保持简洁。
2. 灵活性：可以容易地生成不同表现形式的产品，只需更换具体构建器。
3. 逐步构建：支持逐步构造一个复杂对象，允许按步骤设置不同的属性，适用于具有多个可选配置的场景。
4. 代码复用：相同构建过程可用于创建不同配置的产品。

### 注意事项
1. 构建步骤明确性：确保构建过程的逻辑清晰，避免构建过程过于复杂难以理解和维护。
2. 避免过度设计：对于简单对象的创建，使用构建器模式可能会造成不必要的复杂度。
3. 构建器与产品关系：确保构建器和产品类的设计紧密关联，但又保持足够的独立性，以便于扩展。
4. 内存管理：在构建复杂对象时，注意内存分配和释放，避免内存泄漏。

### 如何深入理解
1. 实践案例：通过实现一个具体的应用案例，比如构建一个配置多样的计算机对象，理解构建器模式如何分步构建复杂对象。
2. 模式对比：将构建器模式与其他创建型模式（如工厂模式、抽象工厂模式）进行比较，理解各自的适用场景和差异。
3. 设计原则：结合SOLID原则理解构建器模式如何实现单一职责原则，如何通过接口隔离变化，以及如何支持开闭原则。
4. 源码分析：研究成熟库或框架中构建器模式的实现，理解其实现细节和最佳实践。

### 面向对象特性的体现
1. 封装：构建器模式通过将对象的构建过程封装在具体的构建器类中，隐藏了对象创建的具体步骤和内部细节。这符合面向对象设计中的封装原则，即隐藏实现细节，只暴露必要的接口给外部世界。

2. 继承与多态：具体构建器作为构建器接口的子类，利用继承实现了接口的多态性。这意味着，尽管构建流程相同，但通过替换不同的具体构建器，可以创建出不同类型的或配置的产品对象，体现了面向对象的多态性。

3. 抽象与具体化：产品类定义了构建结果的抽象接口，而构建器则关注于这个结果的构建过程。这种分离抽象定义与具体实现的方式，是面向对象设计中“程序对抽象的依赖而非具体”的直接应用。

### 独特设计思路
1. 逐步构建与解耦：构建器模式的核心在于将复杂的构建过程分解为一系列简单的步骤，每一步都通过方法调用来完成，这样做的好处是每个步骤可以独立修改而不影响其他步骤，大大提高了系统的灵活性和可维护性。

2. 关注点分离：它将对象的构造（构造逻辑和参数）与表示（最终的产品对象）分离，使得构造逻辑可以独立于产品类变化，体现了“单一职责原则”。

### 设计模式特点的体现
1. 可重用性：构建器模式通过定义清晰的接口和实现，使得构建逻辑可以在不同的上下文中重用，减少了代码重复。

2. 灵活性：能够动态地调整产品的内部结构和表现形式，只需修改具体构建器类，无需改动产品类或客户端代码，增强了系统的适应性和扩展性。

3. 复杂性管理：通过将复杂的构建过程封装，降低了客户端代码的复杂度，使得系统更加易于理解和维护。

### 设计哲学
构建器模式体现了“间接性”这一重要的设计哲学，即通过引入间接层（构建器）来降低系统的复杂性和耦合度。它还强调了“延迟决策”原则，即在构建过程中逐步确定对象的属性，而不是一开始就全部确定，这增加了设计的灵活性。


### 适用情况
1. 复杂对象创建：当对象的创建过程涉及到多个步骤，且这些步骤的顺序和选择可能不同。
2. 可变配置：需要创建具有多种可能配置的对象，且配置选项间存在依赖或逻辑关系。
3. 避免构造函数污染：当对象的构造参数过多，或者构造参数之间存在默认值和可选值的情况，避免构造函数签名过长和难于理解。

## 例子
下面是一个C++中构建器模式的标准例子，我们以构建一个电脑配置为例来展示构建器模式的使用。电脑配置包括CPU、内存、硬盘等组件，每个用户的配置需求可能不同，因此使用构建器模式可以很好地处理这种复杂对象的构建过程。
```cpp
#include <string>

// 定义电脑产品类（Product）
class Computer {
public:
    std::string cpu;
    std::string ram;
    std::string hdd;

    void showConfig() {
        std::cout << "Computer Configuration:\n"
                  << "CPU: " << cpu << "\n"
                  << "RAM: " << ram << "\n"
                  << "HDD: " << hdd << std::endl;
    }
};

// 创建具体构建器（ConcreteBuilder）：
class HighEndComputerBuilder : public ComputerBuilder {
private:
    Computer computer;

public:
    void setCPU(const std::string& cpuType) override {
        computer.cpu = cpuType + " (High Performance)";
    }

    void setRAM(const std::string& ramSize) override {
        computer.ram = ramSize + "GB DDR4";
    }

    void setHDD(const std::string& hddSize) override {
        computer.hdd = hddSize + "TB SSD";
    }

    Computer* getComputer() override {
        return new Computer(computer); // 实际中应考虑智能指针或工厂模式来优化内存管理
    }
};

// 定义一个导演类（Director）来管理构建过程：
class Director {
private:
    ComputerBuilder* builder;

public:
    Director(ComputerBuilder* builderPtr) : builder(builderPtr) {}

    void constructComputer() {
        builder->setCPU("Intel i9");
        builder->setRAM("32");
        builder->setHDD("1");
    }
};

// 客户端代码使用这些类来构建电脑配置：
int main() {
    Director director(new HighEndComputerBuilder());
    director.constructComputer();

    Computer* highEndComputer = director.builder->getComputer();
    highEndComputer->showConfig();

    delete highEndComputer; // 记得释放内存，或使用智能指针
    return 0;
}
```
这个例子中，Computer 是产品类，ComputerBuilder 是构建器接口，HighEndComputerBuilder 是具体构建器，Director 是导演类，它负责指导构建过程。通过这样的设计，我们可以轻松地创建不同配置的电脑对象，而且可以很容易地扩展以支持更多类型的电脑配置。