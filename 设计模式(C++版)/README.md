# C++设计模式

## 什么是设计模式
“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。
——Christopher Alexander

## 如何解决复杂性？
+ 分解
  + 人们面对复杂性有一个常见的做法：即分而治之，将大问题分解为多个小问题，将复杂问题分解为多个简单问题。
+ 抽象
  + 更高层次来讲，人们处理复杂性有一个通用的技术，即抽象。由于不能掌握全部的复杂对象，我们选择忽视它的非本质细节，而去处理泛化和理想化了的对象模型。
  
## 底层思维 和 抽象思维
底层思维：向下，如何把握机器底层
从微观理解对象构造
• 语言构造
• 编译转换
• 内存模型
• 运行时机制

抽象思维：向上，如何将我们的周围
世界抽象为程序代码
• 面向对象
• 组件封装
• 设计模式
• 架构模式

## 深入理解面向对象
向下：深入理解三大面向对象机制
•封装，隐藏内部实现
•继承，复用现有代码
•多态，改写对象行为
向上：深刻把握面向对象机制所带来的抽象意义，理解如何使用
这些机制来表达现实世界，掌握什么是“好的面向对象设计”

## 面向对象设计原则
1. 依赖倒置原则（DIP）
  + 高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。
  + 抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。
2. 开放封闭原则（OCP）
  + 对扩展开放，对更改封闭。
  + 类模块应该是可扩展的，但是不可修改。
3. 单一职责原则（SRP）
  + 一个类应该仅有一个引起它变化的原因。
  + 变化的方向隐含着类的责任。
4. Liskov 替换原则（LSP）
  + 子类必须能够替换它们的基类(IS-A)。
  + 继承表达类型抽象。
5. 接口隔离原则（ISP）
  + 不应该强迫客户程序依赖它们不用的方法。
  + 接口应该小而完备。
6. 优先使用对象组合，而不是类继承
  + 类继承通常为“白箱复用”，对象组合通常为“黑箱复用” 。
  + 继承在某种程度上破坏了封装性，子类父类耦合度高。
  + 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。
7. 封装变化点
  + 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。
8. 针对接口编程，而不是针对实现编程
  + 不将变量类型声明为某个特定的具体类，而是声明为某个接口。
  + 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。
  + 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案。

## 从封装变化角度对模式分类
### “组件协作”模式：
现代软件专业分工之后的第一个结果是“框架与应用程序的划分”，“组件协作”模式通过晚期绑定，来实现框架与应用程序之间的松耦合，是二者之间协作时常用的模式。
+ [Template Method 模板方法](Template-Method/Template-Method.md)
+ [Strategy 策略模式](Strategy/Strategy.md)
+ [Observer/Event 观察者模式](Observer/Observer.md)
### “单一职责”模式：
在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。
+ [Decorator 装饰模式](Decorator/Decorator.md)
+ [Bridge 桥接模式](Bridge/Bridge.md)
### “对象创建”模式
通过"对象创建"模式绕开new，来避免对象创建(new)过程中所导致的紧耦合(依赖具体类)，从而支持对象创建的稳定，它是接口抽象之后的第一步工作。
+ [Simple-Factroy 简单工厂模式](Simple-Factroy/Simple-Factroy.md)
+ [Factory-Method 工厂方法模式](Factory-Method/Factory-Method.md)
+ [Abstract Factory 抽象工厂模式](Abstract-Factory/Abstract-Factory.md)
+ [Prototype 原型模式](Prototype/Prototype.md)
+ [Builder 构建器模式](Builder/Builder.md)
### “对象性能”模式
面向对象很好的解决了"抽象"的问题，但不可避免的要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况，面型对象所带来的成本必须谨慎处理。
+ [Singleton 单例模式](Singleton/Singleton.md)
+ [Flyweight 享元](Flyweight/Flyweight.md)
### “接口隔离模式”
在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现，采用添加一层间接(稳定)接口，来隔离本来相互紧密关联的接口是一种常见的解决方案。
+ [Façade 门面模式](Facade/Facade.md)
+ [Proxy 代理模式](Proxy/Proxy.md)
+ [Adapter 适配器模式](Adapter/Adapter.md)
+ [Mediator 中介者模式](Mediator/Mediator.md)

## 重构获得模式 Refactoring to Pattern
面向对象设计模式是“好的面向对象设计”，所谓“好的面向对象设计”指是那些可以满足 “应对变化，提高复用”的设计 。

现代软件设计的特征是“需求的频繁变化”。设计模式的要点是“寻找变化点，然后在变化点处应用设计模式，从而来更好地应对需求的变化”.“什么时候、什么地点应用设计模式”比“理解设计模式结构本身”更为重要。

设计模式的应用不宜先入为主，一上来就使用设计模式是对设计模式的最大误用。没有一步到位的设计模式。敏捷软件开发实践提倡的“Refactoring to Patterns”是目前普遍公认的最好的使用设计模式的方法。

## 重构关键技法
静态 -> 动态
早绑定 -> 晚绑定
继承 -> 组合
编译时依赖 -> 运行时依赖
紧耦合 -> 松耦合