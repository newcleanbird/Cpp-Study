# Façade(门面模式) / 外观模式
门面模式（Facade Pattern）属于设计模式中的结构型模式，其主要目的是为一组复杂的子系统提供一个简化的统一接口，使得客户端与子系统的交互变得更为简单。门面模式隐藏了系统的复杂性，并降低了客户端与子系统之间的耦合度。

## “接口隔离模式”
在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现，采用添加一层间接(稳定)接口，来隔离本来相互紧密关联的接口是一种常见的解决方案。

## 动机(Motivation)
+ 客户和组件中各种复杂的子系统有过多的耦合
+ 如何简化外部客户程序和系统间的交互接口？如何解耦？

## 模式定义
为子系统中的一组接口提供一个一致(稳定)的界面，Façade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用(复用)。
——《设计模式》GoF

## 要点总结
+ 从客户程序角度来看，Façade模式简化了整个组件系统的接口，对于组件内部与外部的客户程序来说，
达到了一种”解耦“的效果——内部子系统的任何变化不会影响到Façade接口的变化。
+ Façade设计模式更注重架构的层次去看整个系统，而不是单个类的层次。Façade很多时候是一种架构设计模式。
+ Façade设计模式并非一个集装箱，可以任意地放进任何多个对象。Façade模式组件中的内部应该是”相互耦合关系比较大的一系列组件“，而不是一个简单的功能集合。

## 深入
### 实现要点
1. 门面接口（Facade）：定义了一个高层接口，让客户端可以更容易地与子系统进行交互。
2. 子系统类（Subsystems）：实现了实际的业务逻辑，这些类通常包含多个类和接口，且相互之间可能存在复杂的交互。
3. 门面实现（Facade Implementation）：门面类的实现中，它聚合了多个子系统的对象，并通过这些对象调用子系统的功能，对客户端暴露一个简单的接口。

### 优点
1. 简化接口：为复杂的子系统提供了一个简单、统一的接口，使得客户端调用更加便捷。
减少耦合：降低了客户端与子系统之间的直接依赖，提高了系统的可维护性和可扩展性。
提高灵活性：添加新的子系统或者修改现有子系统时，只需修改门面类，客户端代码一般不需要调整。
2. 提高重用性：门面类可以被多个客户端重用，避免了重复编写复杂的调用逻辑。

### 注意事项
1. 不要过度封装：门面应当提供必要的接口，但过度封装可能会隐藏子系统的灵活性和功能。
2. 保持门面的精简：门面应尽量保持简单，避免自身成为另一个复杂的子系统。
3. 设计时考虑扩展性：随着系统的发展，门面接口可能需要扩展以适应新需求，设计时应考虑未来的变化。
4. 文档和注释：由于门面隐藏了子系统的细节，良好的文档和注释对于理解系统的工作流程至关重要。

### 适用情况
1. 系统重构：现有系统过于复杂，接口混乱，难以理解和使用时，可以通过门面模式提供统一的简化接口。
2. API设计：为复杂的API库提供一个简单易用的前端接口。
3. 第三方集成：作为客户端与第三方系统或库的交互层，隔离外部系统的复杂性。
4. 降低耦合：当需要减少客户端与子系统之间的直接依赖，以便于独立更改子系统时。

### 面向对象特性的体现
1. 封装：门面模式利用面向对象的封装特性，将复杂的子系统内部结构和实现细节隐藏起来，只暴露一个简单的、高层次的接口给客户端使用。这样做不仅减少了客户端对子系统的认知负担，也使得子系统内部的修改对客户端透明，增强了系统的稳定性。

2. 抽象：通过定义一个门面接口，提供了一层抽象，使得客户端与子系统的交互变得更加间接。这种抽象有助于解耦，使得客户端代码不直接依赖于子系统的具体实现，而是依赖于抽象的门面接口。

3. 多态：虽然门面模式本身不一定直接体现多态特性，但它与多态相结合可以增强灵活性。例如，可以定义多个门面类，每个类针对不同场景提供特定的接口，而客户端通过基类指针或引用操作门面，利用多态特性调用不同实现。

### 内涵独特的设计思路
1. 简化接口：门面模式专注于提供一个清晰、简洁的接口，这个接口通常比直接使用子系统提供的功能要更易于理解和使用，它反映了系统对外部的“契约”，而隐藏了内部复杂性。

2. 层次分明：通过引入门面，可以构建清晰的层次结构，上层调用者仅需与门面交互，无需了解底层实现细节，这有利于系统分层和模块化设计，便于维护和扩展。

3. 设计哲学：门面模式体现了“最少知识原则”（Least Knowledge Principle，也称作迪米特法则），即一个对象应当尽可能少地了解其他对象，门面作为一个中介，减少客户端直接与多个子系统之间的交互，从而降低耦合度。

### 设计模式特点
1. 结构性优化：门面模式不是创造新的设计，而是对现有设计的结构进行优化，通过引入一个抽象层来改善系统的结构和可理解性。

2. 关注点分离：它强调将复杂的子系统操作与客户端的调用分离，使得客户端可以专注于自己的业务逻辑，而不必了解底层实现的复杂性。

3. 灵活性与可测试性：通过门面模式，可以在不改动客户端代码的情况下替换或添加新的子系统，提高了系统的灵活性。同时，门面的单一接口也简化了单元测试，可以独立测试门面及其背后的子系统。

## 例子
以下是一个C++中实现门面模式的标准示例，我们将构建一个简单的多媒体播放器系统，该系统包含多个子系统，如音频播放、视频播放和字幕处理。门面模式将用于为用户提供一个统一的接口来控制整个播放过程，而无需了解每个子系统的复杂操作。
```cpp
// 子系统类
class AudioPlayer {
public:
    void playAudio(const std::string& fileName) {
        std::cout << "Playing audio file: " << fileName << std::endl;
    }
};

class VideoPlayer {
public:
    void playVideo(const std::string& fileName) {
        std::cout << "Playing video file: " << fileName << std::endl;
    }
};

class SubtitleManager {
public:
    void displaySubtitle(const std::string& subtitle) {
        std::cout << "Displaying subtitle: " << subtitle << std::endl;
    }
};

// 门面类 将上述子系统组合在一起，并提供一个简单的接口给客户端使用：

class MediaPlayerFacade {
private:
    AudioPlayer audioPlayer;
    VideoPlayer videoPlayer;
    SubtitleManager subtitleManager;
public:
    void playMovie(const std::string& movieFile, const std::string& subtitleFile) {
        audioPlayer.playAudio(movieFile);
        videoPlayer.playVideo(movieFile);
        subtitleManager.displaySubtitle(subtitleFile);
        std::cout << "Enjoy your movie!" << std::endl;
    }
};

// 客户端 通过门面类来播放电影，而无需直接与音频播放器、视频播放器或字幕管理器打交道：

int main() {
    MediaPlayerFacade mediaPlayer;
    mediaPlayer.playMovie("movie.mp4", "movie.srt");
    return 0;
}
```
在这个例子中，MediaPlayerFacade类作为门面，为客户端提供了一个统一的方法playMovie来启动电影播放，这个方法内部调用了各个子系统的具体操作。客户端代码变得非常简洁，不需要了解播放电影所需的所有细节，这正是门面模式的价值所在。