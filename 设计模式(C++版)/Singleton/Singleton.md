# Singleton 单例模式
单例模式是一种创建型设计模式，它保证一个类在整个应用程序中仅有一个实例，并提供一个全局访问点来获取这个实例。单例模式常用于那些需要控制资源访问、协调操作或提供全局服务的场景。在C++中，实现单例模式可以通过多种方式，但关键在于确保类的实例化过程受控且唯一。

## 动机(Motivation)
+ 在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率。
+ 如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？
+ 这应该是类设计者的责任，而不是使用者的责任。

## 模式定义
保证一个类仅有一个实例，并提供一个该实例的全局访问点。
——《设计模式》GoF

## 要点总结
+ Singleton模式中的实例构造器可以设置为protected以允许子类派生。
+ Singleton模式一般不要支持拷贝构造函数和Clone接口，因为这有可能导致多个对象实例，与Singleton模式的初中违背。
+ 如何实现多线程环境下安全的Singleton？注意对双检查锁的正确实现。

## 详解
### 基本实现方式
1. 懒汉式（Lazy Initialization）：在首次请求实例时才创建单例对象。需注意线程安全问题。
2. 饿汉式（Eager Initialization）：在类加载时就立即创建单例对象，保证线程安全，但可能会造成资源浪费。
3. 双重检查锁定（Double-Checked Locking）：结合懒汉式和性能优化，减少锁的开销，同时保证线程安全。
4. 局部静态变量（C++11之后推荐）：利用局部静态变量的特性，实现线程安全且高效的单例初始化。
```cpp
class Singleton {
private:
    Singleton() {} // 私有构造函数
    Singleton(const Singleton&) = delete; // 禁止拷贝构造
    Singleton& operator=(const Singleton&) = delete; // 禁止赋值操作

public:
    static Singleton& getInstance() {
        static Singleton instance; // 局部静态变量，线程安全且懒惰初始化
        return instance;
    }

    // 其他公共接口函数...
};
```

### 优点
1. 控制资源访问：对于那些需要控制共享资源访问的场景，如数据库连接池、日志文件等，单例模式提供了一个全局访问点。
2. 简化配置：单例对象可以作为配置的中心点，使得配置的修改对整个应用的影响集中且可控。
3. 全局唯一性：保证某些操作的唯一性，比如序列号生成器、线程池管理器等。

### 缺点：
1. 一般没有接口，扩展困难。原因：接口对单例模式没有任何意义；要求“自行实例化”，并提供单一实例，接口或抽象类不可能被实例化。（当然，单例模式可以实现接口、被继承，但需要根据系统开发环境判断）
2. 单例模式对测试是不利的。如果单例模式没完成，是不能进行测试的。
3. 单例模式与单一职责原则有冲突。原因：一个类应该只实现一个逻辑，而不关心它是否是单例，是不是要单例取决于环境；单例模式把“要单例”和业务逻辑融合在一个类。

### 注意事项
1. 线程安全：确保单例的创建是线程安全的，特别是在多线程环境下。
2. 测试困难：由于单例的全局状态，它可能会使单元测试变得复杂，因为测试之间会共享状态。
3. 滥用风险：过度使用单例可能会导致过度耦合，降低代码的可测试性和可维护性。
4. 扩展性：单例模式可能限制了对象的扩展性，特别是在需要多个实例或不同配置的场景下。
5. 类中其他方法，尽量是static。

### 如何深入理解
1. 模式对比：将单例模式与其他创建型模式（如工厂模式、构建器模式）进行对比，理解它们之间的应用场景和优缺点。
2. 设计原则：思考单例模式如何体现设计模式的原则，如单一职责原则、开闭原则等。
3. 源码分析：研究开源库或框架中的单例实现，理解它们如何处理线程安全、初始化时机等问题。
4. 实践与反思：在实际项目中尝试应用单例模式，并反思其带来的好处与潜在问题。

### 适用情况
1. 资源共享：需要控制对共享资源（如数据库、硬件设备）的访问时。
2. 全局服务：提供如日志记录、配置管理等全局服务的场景。
3. 控制行为：需要控制某个行为或操作在应用程序中只发生一次时，如初始化操作。
4. 要求生成唯一序列化的环境.
5. 项目需要的一个共享访问点或共享的数据点.
6. 创建一个对象需要消耗资源过多的情况。如：要访问IO和 数据库等资源。
7. 需要定义大量的静态常量和静态方法（如工具类）的环境。可以采用单例模式或者直接声明static的方式。


### 面向对象特性的体现
1. 封装: 单例模式通过将实例化的细节隐藏在类内部，确保了对象创建过程对外界的不可见性，这是封装原则的直接体现。外部用户无需知道单例是如何被创建的，只需通过一个公共接口获取实例即可。

2. 抽象: 单例模式强调的是“全局唯一实例”的概念，而非具体的实现细节。这鼓励我们关注于接口（即获取单例的方法）而非实现，体现了抽象思维。

3. 继承与多态（非直接相关，但在设计上可考虑）: 虽然单例模式本身不直接依赖于继承或多态，但在复杂的系统设计中，单例类可以通过继承自一个抽象基类来实现多态性，从而允许在不同的上下文中复用单例模式的逻辑，同时也保持了设计的灵活性。

### 独特设计思路
1. 全局唯一性: 单例模式的核心在于确保一个类在任何时刻、任何位置都只有一个实例存在。这种设计思路直接应对了需要全局控制资源或行为的需求，如配置管理、日志记录等场景。

2. 延迟初始化: “懒汉”式的单例实现体现了延迟初始化的思想，即直到真正需要时才创建实例，这样可以节省资源，尤其是在对象创建成本较高或不总是需要的情况下。

3. 控制访问: 通过私有构造函数、拷贝构造函数及赋值运算符的禁用，单例模式严格控制了对象的创建和复制，确保了全局唯一性的实现。

### 设计模式的特点体现
1. 可重用性: 单例模式提供了一种通用的解决方案来处理需要全局访问点的问题，可以在不同的项目或系统中重复使用这一模式。

2. 灵活性与扩展性: 虽然单例模式有时因全局状态而受到批评，但通过设计良好的接口和遵循开放封闭原则，单例类可以被灵活替换或扩展，以适应变化的需求。

3. 设计哲学: 单例模式体现了设计模式的“模式而非巧合”原则，即通过一种经过验证的、标准化的方式来解决常见问题，而非每次遇到问题时都从零开始设计。


## 例子
1. 懒汉式（线程不安全版）
懒汉式单例会在第一次被请求时创建实例，但是下面的实现没有考虑线程安全问题：
```cpp
class SingletonLazyUnsafe {
private:
    static SingletonLazyUnsafe* instance;
    SingletonLazyUnsafe() {} // 私有构造函数
public:
    static SingletonLazyUnsafe* getInstance() {
        if (instance == nullptr) {
            instance = new SingletonLazyUnsafe();
        }
        return instance;
    }
};

// 初始化静态成员
SingletonLazyUnsafe* SingletonLazyUnsafe::instance = nullptr;
```

2. 饿汉式
饿汉式在类加载时就完成了实例化，天然线程安全，但可能会提前占用资源：
```cpp
class SingletonEager {
private:
    SingletonEager() {} // 私有构造函数
    static SingletonEager instance;
public:
    static SingletonEager* getInstance() {
        return &instance;
    }
};

// 静态实例在编译期创建，线程安全
SingletonEager SingletonEager::instance;
```

3. 懒汉式（线程安全，双重检查锁定）
双重检查锁定(DCLP)在懒汉式基础上增加线程安全性，减少锁的开销：
```cpp
class SingletonLazyDCLP {
private:
    static SingletonLazyDCLP* instance;
    SingletonLazyDCLP() {} // 私有构造函数
public:
    static SingletonLazyDCLP* getInstance() {
        if (instance == nullptr) {
            std::lock_guard<std::mutex> lock(mutex); // 加锁
            if (instance == nullptr) { // 第二次检查
                instance = new SingletonLazyDCLP();
            }
        }
        return instance;
    }
private:
    static std::mutex mutex;
};

// 初始化静态成员
SingletonLazyDCLP* SingletonLazyDCLP::instance = nullptr;
std::mutex SingletonLazyDCLP::mutex;
```

4. 局部静态变量（C++11推荐）
利用局部静态变量的特性实现线程安全且高效的懒汉式单例：
```cpp
class SingletonLocalStatic {
private:
    SingletonLocalStatic() {} // 私有构造函数
public:
    static SingletonLocalStatic& getInstance() {
        static SingletonLocalStatic instance; // 局部静态变量，线程安全且懒惰初始化
        return instance;
    }
};
```
整体工作原理:
当首次调用SingletonLocalStatic::getInstance()时，编译器确保instance会被构造一次，并且这个初始化过程是线程安全的。之后的调用直接返回同一个instance的引用，保证了全局范围内只有一个SingletonLocalStatic的实例存在。这种方式既实现了延迟初始化（懒汉式），又避免了复杂的线程同步问题，是一种高效且简洁的单例模式实现方法。

### 总结
**懒汉式（线程不安全版）**是最基础的实现，但在多线程环境下不可靠。
**饿汉式**解决了线程安全问题，但牺牲了部分资源效率，适用于资源占用不大或确定性高的场景。
**双重检查锁定**在懒汉式基础上增加了线程安全，是多线程环境下常用的懒汉式实现方式。
**局部静态变量**是C++11引入后推荐的实现方式，因为它既保证了线程安全，又利用了局部静态变量的延迟初始化特性，实现简单且高效。
