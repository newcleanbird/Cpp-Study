# Prototype 原型模式
原型模式是一种创建型设计模式，其核心思想是通过复制现有对象（即原型）来创建新对象，而不是通过新建实例的过程。这种方式可以简化对象的创建过程，尤其是在创建对象的代价较大（例如，需要大量计算或资源消耗）或者创建过程复杂的情况下。

## 动机(motivation)
+ 在软件系统中，经常面临这“某些结构复杂的对象”的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是它们却拥有比较稳定一致的接口。
+ 如何应对这种变化？如何向“客户程序(使用这些对象的程序)”隔离出“这些易变对象”，从而使得依赖这些”易变对象“的客户程序不随着需求改变而改变。

“复杂结构”：当使用工厂方法很难创建出需要状态的对象，就考虑用原型模式。

## 模式定义
使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。
——《设计模式》GoF

## 要点总结
+ Prototype模式同样用于隔离对象的使用者和具体类型(易变类)之间的耦合关系，它同样要求这些“易变类”拥有稳定的接口。
+ Prototype模式对于“如何创建易变类的实体对象“采用”原型克隆“的方法来做，
它使得我们可以非常灵活地动态创建”拥有某些稳定接口“的新对象——所需工作仅仅是注册一个新类的对象(即原型)，
然后在任何需要的地方Clone。
+ Prototype模式中的Clone方法可以利用某些框架中的序列化来实现深拷贝。

## 详解原型模式
### 实现机制
- 浅复制与深复制：C++中的原型模式实现需要考虑对象复制的深度。默认的拷贝构造函数和赋值运算符通常提供的是浅复制，即只复制对象的基本数据成员，而共享指针或引用类型的数据成员。如果需要复制对象的所有状态，包括指针所指向的数据，就需要实现深复制。

- Clone接口：为了使对象能够被复制，原型类通常会定义一个克隆自身的接口，如虚函数virtual std::unique_ptr<Prototype> clone() const = 0;。具体原型类需要实现这个接口以返回自身的一个深或浅复制。

### 优点
1. 性能提升：对于复杂的对象创建，直接复制现有对象比重新创建对象更快，减少了资源消耗。
2. 简化对象创建：客户端无需了解对象的创建细节，只需请求原型的复制即可。
3. 灵活性：可以在运行时动态决定创建哪种类型的对象，只需改变所复制的原型即可。
4. 易于扩展：增加新的原型类型无需修改现有代码，符合开闭原则。

### 注意事项
1. 深浅复制的问题：必须明确区分何时使用浅复制，何时使用深复制。错误的复制方式可能导致资源泄露或数据不一致。
2. 内存管理：复制对象时，特别是深复制，需要谨慎处理内存管理，避免内存泄漏。
3. 设计复杂度：原型模式的引入可能增加系统的复杂度，特别是当原型类层次复杂时，需要仔细设计复制逻辑。
4. 原型对象的状态：确保原型对象的状态在复制前是正确的，因为新对象将继承原型的状态。

### 如何深入理解
1. 动手实践：亲自实现几个原型模式的例子，包括简单和复杂的情况，以理解其工作原理和适用场景。
2. 对比学习：与工厂模式等其他创建型模式对比，理解它们之间的异同点。
3. 源码阅读：阅读开源项目中原型模式的实现，理解其在实际应用中的细微差别。
4. 设计模式书籍：研读《设计模式：可复用面向对象软件的基础》等书籍中关于原型模式的部分，加深理论理解。

### 适用情况
1. 对象创建成本高：当创建对象的过程耗时长或资源消耗大时，通过克隆现有对象可以快速获得新对象。
2. 对象类型运行时确定：如果需要创建的对象类型直到运行时才能确定，原型模式可以动态复制适当类型的对象。
3. 对象修改频繁：当对象经常需要修改，且修改后需要创建多个相似的新对象时，原型模式能简化这一过程。

### 面向对象的体现
1. 多态性：通过声明一个抽象基类（原型接口）并定义一个克隆方法，具体原型类通过继承该基类并实现克隆方法，展现了多态行为。这意味着客户端代码可以以统一的方式处理所有类型的原型，而无需知道它们具体的类型。

2. 封装性：原型模式通过将对象的复制逻辑封装在原型对象内部，隐藏了对象创建的细节。外部用户不需要了解对象是如何被复制的，只需调用克隆方法即可，这加强了系统的模块化和降低了各部分之间的耦合度。

3. 继承性：虽然原型模式并不强制使用继承，但它通常基于类的继承结构来实现。具体原型类继承自抽象原型类，这样就可以复用和扩展基类的行为和属性。

### 设计思路与设计哲学
1. 复用性与灵活性：原型模式的核心思想在于复用现有对象的配置或状态，避免了复杂的初始化过程。这不仅提高了效率，也使得系统更加灵活，能够快速适应需求变化。

2. 避免性能开销：对于那些初始化开销大或者构造过程复杂的对象，直接复制一个已经存在的实例比通过构造函数创建新实例要高效得多。

3. 简化对象创建逻辑：设计中将对象的创建逻辑委托给对象本身管理，减少了工厂模式或建造者模式中可能需要的复杂逻辑，使得代码更简洁、易于维护。

### 设计模式的特点
设计模式的通用性：原型模式展示了设计模式的普遍适用性，它不依赖于特定的应用领域，任何需要快速、低成本创建相似对象的场景都可应用此模式。

强调‘不要重新发明轮子’：通过复制现有对象，原型模式鼓励重用已有的资源，避免重复劳动，这符合设计模式提倡的高效开发理念。

接口隔离与低耦合：通过抽象基类定义克隆操作，确保了客户端与具体原型类之间的松耦合，客户端仅依赖于抽象接口，有利于软件的扩展和维护。

## 例子
在C++中实现原型模式，我们通常定义一个基类作为原型接口，并在其中声明一个克隆自身的虚函数。具体原型类将实现这个克隆函数，根据需要进行深复制或浅复制。以下是一个简单的例子，展示了如何使用原型模式来复制图形对象：
```cpp
#include <iostream>
#include <memory>

// 抽象原型类，定义克隆接口
class ShapePrototype {
public:
    virtual ~ShapePrototype() {}
    virtual std::unique_ptr<ShapePrototype> clone() const = 0;
    virtual void draw() const = 0;
};

// 具体原型类：圆形
class CirclePrototype : public ShapePrototype {
private:
    int radius;
public:
    CirclePrototype(int r) : radius(r) {}
    std::unique_ptr<ShapePrototype> clone() const override {
        return std::make_unique<CirclePrototype>(*this);
    }
    void draw() const override {
        std::cout << "Drawing Circle with radius: " << radius << std::endl;
    }
};

// 具体原型类：方形
class SquarePrototype : public ShapePrototype {
private:
    int side;
public:
    SquarePrototype(int s) : side(s) {}
    std::unique_ptr<ShapePrototype> clone() const override {
        return std::make_unique<SquarePrototype>(*this);
    }
    void draw() const override {
        std::cout << "Drawing Square with side: " << side << std::endl;
    }
};

int main() {
    // 创建原型对象
    std::unique_ptr<ShapePrototype> circlePrototype = std::make_unique<CirclePrototype>(5);
    std::unique_ptr<ShapePrototype> squarePrototype = std::make_unique<SquarePrototype>(4);

    // 克隆原型对象并绘制
    std::unique_ptr<ShapePrototype> clonedCircle = circlePrototype->clone();
    std::unique_ptr<ShapePrototype> clonedSquare = squarePrototype->clone();

    clonedCircle->draw();  // 输出: Drawing Circle with radius: 5
    clonedSquare->draw(); // 输出: Drawing Square with side: 4

    return 0;
}
```
在这个例子中，ShapePrototype 是抽象原型类，它声明了一个纯虚函数 clone() 用于克隆自身，以及一个 draw() 函数用于展示图形。CirclePrototype 和 SquarePrototype 分别是圆形和方形的具体原型类，它们实现了 clone() 方法来创建自己的副本，并实现了 draw() 方法来展示图形。在 main() 函数中，我们创建了原型对象，并通过调用 clone() 方法来创建它们的副本，最后调用 draw() 方法展示这些图形。这个例子演示了原型模式的基本用法和优势，即通过克隆现有对象来快速创建新的对象，特别是在创建过程复杂或成本较高的情况下。