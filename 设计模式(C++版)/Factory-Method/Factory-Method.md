# Factory Method 工厂方法模式
C++中的工厂方法模式（Factory Method Pattern）是一种创建型设计模式，它定义了一个用于创建对象的接口，但允许子类决定实例化哪一个类。这使得一个类的实例化延迟到其子类，从而提供了高度的可扩展性和灵活性。

## 对象创建模式
通过"对象创建"模式绕开new，来避免对象创建(new)过程中所导致的紧耦合(依赖具体类)，从而支持对象创建的稳定，它是接口抽象之后的第一步工作。

## 动机（Motivation）
+ 在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变化。
+ 如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“具体对象创建工作”的紧耦合？

## 模式定义
定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟（目的：解耦，手段：虚函数）到子类。
——《设计模式》GoF

## 要点总结
+ Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导致软件的脆弱。
+ Factory Method模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。
+ Factory Method模式解决“单个对象”的需求变化。缺点在于要求创建方法/参数相同。

## 面向接口编程
标志：变量要声明成抽象基类

## 基本结构
工厂方法模式通常涉及以下几个角色：

1. 产品接口（Product Interface）：定义了所有具体产品都必须实现的接口或抽象类。
2. 具体产品（Concrete Products）：实现产品接口的类，代表不同的产品对象。
3. 工厂接口（Factory Interface）：声明创建产品对象的接口，通常是一个创建方法。
4. 具体工厂（Concrete Factories）：实现工厂接口，负责创建具体产品对象，每个具体工厂对应一种具体产品。

## 优点
1. 遵循开闭原则：可以轻易地添加新的产品种类，只需要添加新的产品类和对应的工厂类，不需要修改现有的代码。
2. 降低耦合：客户端代码不直接依赖于具体产品类，而是依赖于抽象，减少了对象间的耦合。
3. 易于扩展和维护：系统结构清晰，易于扩展新的功能和维护。
4. 隐藏创建逻辑：产品的创建过程被封装在工厂中，客户端无需关心对象的创建细节。

## 注意事项
1. 类爆炸问题：随着产品和工厂类的增加，类的数量会迅速增长，可能导致系统结构复杂。
2. 过度设计：对于简单的对象创建需求，使用工厂方法模式可能会引入不必要的复杂度。
3. 性能考虑：频繁使用反射或动态创建对象可能影响性能。

## 适用情况
1. 系统需要多种相似对象，并且这些对象的创建逻辑可能随时间变化。
2. 客户端不知道也不应关心它所使用的具体产品的类。
3. 需要提供一个统一的接口来创建一组相关或相互依赖的对象。
4. 预期会有新的产品类型加入到系统中，但不想修改现有的客户端代码。

## 深入理解工厂模式方法
工厂方法模式是一种高度灵活的设计模式，它体现了面向对象设计中的两个核心原则：抽象和多态。这一模式的核心在于解耦了对象的创建过程与使用过程，通过引入一个工厂接口和具体工厂类，使得系统能够更加灵活地应对变化，尤其是当系统需要处理多种不同但又相互关联的对象创建时。

### 抽象与多态的应用
在工厂方法模式中，"抽象"体现在两个层面：一是产品接口（或抽象类），它定义了所有具体产品共有的操作集合；二是工厂接口，它声明了创建产品的方法。这两个抽象层使得客户端代码可以针对接口编程，而非具体的实现类。"多态"则体现在具体工厂类重写工厂接口中的创建方法，每个具体工厂负责创建一种具体产品，实现了接口方法的不同行为。

### 动态绑定与运行时决策
工厂方法利用动态绑定（在C++中是虚函数机制），使得具体产品的创建决策可以延迟到运行时。这意味着，我们可以在程序执行过程中根据条件选择创建哪种产品，而无需在编译时期就确定。这种灵活性为系统的扩展和配置提供了便利。

### 开闭原则的体现
开闭原则要求软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。工厂方法模式完美符合这一原则：要添加新的产品类型，我们只需要增加一个新的产品类和一个相应的具体工厂类，而不需要修改任何已有的代码。这不仅降低了引入错误的风险，也使得系统的维护和升级变得更加容易。

### 设计哲学与权衡
工厂方法模式体现了设计模式的一个重要哲学——编程对接口而非实现。这样做提高了代码的可读性、可测试性和可维护性。然而，这种模式也有其成本，比如增加了类的数量，可能造成类爆炸问题，以及由于使用了更多的间接调用，性能上可能会有所损失。因此，在实际应用中，需要根据系统的复杂度和未来的可变性来权衡是否采用工厂方法模式，以及如何合理地设计工厂和产品结构。

总之，工厂方法模式是面向对象设计中处理对象创建复杂性的有效手段，它通过引入抽象层和多态机制，提高了系统的灵活性和可扩展性，同时也促进了代码的模块化和重用。理解并恰当运用这一模式，对于构建高质量的软件系统至关重要。


## 例子
```cpp
#include <iostream>
#include <memory>

// 抽象产品：形状接口
class Shape {
public:
    virtual ~Shape() {}
    virtual void draw() const = 0;
};

// 具体产品：圆形
class Circle : public Shape {
public:
    void draw() const override {
        std::cout << "Drawing Circle" << std::endl;
    }
};

// 具体产品：矩形
class Rectangle : public Shape {
public:
    void draw() const override {
        std::cout << "Drawing Rectangle" << std::endl;
    }
};

// 工厂接口
class ShapeFactory {
public:
    virtual ~ShapeFactory() {}
    virtual std::unique_ptr<Shape> createShape() const = 0;
};

// 具体工厂
class CircleFactory : public ShapeFactory {
public:
    std::unique_ptr<Shape> createShape() const override {
        return std::make_unique<Circle>();
    }
};

class RectangleFactory : public ShapeFactory {
public:
    std::unique_ptr<Shape> createShape() const override {
        return std::make_unique<Rectangle>();
    }
};

// 客户端代码使用这些工厂来创建形状对象并调用它们的draw方法
int main() {
    std::unique_ptr<ShapeFactory> circleFactory = std::make_unique<CircleFactory>();
    std::unique_ptr<ShapeFactory> rectangleFactory = std::make_unique<RectangleFactory>();

    // 使用工厂创建形状并绘制
    std::unique_ptr<Shape> circle = circleFactory->createShape();
    circle->draw();

    std::unique_ptr<Shape> rectangle = rectangleFactory->createShape();
    rectangle->draw();

    return 0;
}
```
在这个例子中，创建了一个简单的形状绘制系统，其中有一个抽象的Shape接口，两个具体形状类Circle和Rectangle作为产品，以及一个形状工厂ShapeFactory来生成具体的形状对象。
这个例子展示了如何使用工厂方法模式来创建不同类型的对象，同时保持了良好的封装性和可扩展性。如果需要添加新的形状类型，只需增加新的形状类和对应的工厂类即可，无需修改现有代码，符合开闭原则。
