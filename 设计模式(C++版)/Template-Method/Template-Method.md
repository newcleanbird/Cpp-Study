# Template Method 模板方法
模板方法旨在定义一个算法的骨架，将具体实现步骤推迟到子类中。

模板方法模式通过抽象类中的模板方法定义了算法的骨架，在此框架中，抽象类会定义好算法的步骤，包括哪些步骤是不变的，哪些步骤需要延迟到子类中去实现。这样做的目的是允许子类在不改变算法结构的前提下，重写或扩展特定的步骤，从而实现代码的复用与维护性。

## 动机（Motivation）
+ 在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。
+ 如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？


## 模式定义
定义一个操作中的算法的骨架 **(稳定)** ，而将一些步骤延迟 **(变化)** 到子类中。
Template Method使得子类可以不改变(复用)一个算法的结构即可重定义(override 重写)该算法的
某些特定步骤。
——《 设计模式》 GoF


## 要点总结
+ Template Method模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制（虚函数的多态性）
为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。
+ 除了可以灵活应对子步骤的变化外， **“不要调用我，让我来调用你”** 的反向控制结构是Template Method的典型应用。
+ 在具体实现方面，被Template Method调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将它们设置为protected方法。

## 理解
要深入理解模板方法，可以从设计原则、应用场景和代码实践等方面进行。
+ 从设计原则上讲，它遵循了开闭原则，即对扩展开放，对修改封闭。
+ 在实际编程中，这意味着我们可以通过新增子类来扩展功能，而无需修改已有的代码。
+ 从应用场景来看，模板方法模式特别适合于那些有固定流程，但各流程间存在细微差异的情况。例如，在一个软件工具类库中，可能会有一个通用的工具使用流程：初始化->执行任务->清理资源。这个流程可以作为模板方法放在抽象类中，而具体的任务执行细节则由各个子类根据需求来实现。
+ 在代码实践中，我们可以通过定义包含模板方法的抽象类和多个实现具体步骤的子类来体会模板方法的工作方式。抽象类中的模板方法定义了固定的算法骨架，而子类则实现了这一算法中可变的部分。这样做的好处在于，新增子类时，我们只需要关注与其相关的特定步骤的实现即可。


## 优点
+ 提高代码复用性：将不变的或相同的代码部分放在抽象的父类中，而将可变的部分放在不同的子类中实现，这样可以减少代码重复。
+ 控制子类的扩展方式，保证算法整体的正确性和可靠性：在父类中定义算法的整体框架，当需要添加新的功能时，可以通过添加新的子类来实现，而不需要修改现有的代码，这符合开闭原则。
+ 简化复杂的算法：通过将一个复杂算法分解成一系列步骤，并将这些步骤的实现延迟到子类中，可以简化复杂的算法。
+ 可以提供一致的接口，从而实现子类的可比较性和可交换性。 通过在父类中定义统一的接口，可以让不同子类的对象可以在相同的条件下进行比较和交换，从而提高程序的可重用性和可扩展性。

## 适用场景
+ 模板方法模式适用于存在一组相似操作的场景，这些操作具有相同的算法结构，但实现细节可能不同。
+ 当希望在不改变算法整体结构的情况下允许子类自由扩展或修改某些步骤时，也适合使用模板方法模式。
+ 该模式可以将算法的实现细节封装起来，只暴露出高层接口供调用者使用。例如，在一个制作豆浆的程序中，制作豆浆的流程（选材->添加配料->浸泡->放到豆浆机打碎）可以在抽象类中定义，而具体的配料选择等步骤可以留给不同的豆浆子类去实现，这样既保证了制作豆浆的基本流程不变，又允许了一定程度的自定义制作步骤。

注意：
1. 算法中有一些步骤是稳定的，而另一些步骤是易变的。 如果算法的步骤都是稳定的，或者都是易变的，则模板方法模式可能不是最佳的选择。
2. 需要对算法进行细粒度的控制和定制。 如果只需要对算法进行粗粒度的控制和定制，则可以考虑使用其他设计模式，如策略模式（Strategy Pattern）或状态模式（State Pattern）。

## 代码示例
适用模板方法的情况：
``template1_lib.h``
```cpp
#include <iostream>

using namespace std;

//程序库开发人员
class Library
{

public:
	void Step1()
	{
		cout << "Step1" << endl;
	}

	void Step3()
	{
		cout << "Step3" << endl;
	}

	void Step5()
	{
		cout << "Step5" << endl;
	}
};
```

``template1_app.cpp``
```cpp
#include "template1_lib.h"

//应用程序开发人员
class Application
{
  public:
	bool Step2()
	{
		cout << "myStep2" << endl;
		return true;
	}

	void Step4()
	{
		cout << "myStep4" << endl;
	}
};

int main()
{
	Library lib;
	Application app;

	lib.Step1();

	if (app.Step2())
	{
		lib.Step3();
	}

	app.Step4();

	lib.Step5();
}
```
分析：``template1_lib.h`` 文件中定义的是``程序库``是不变的，``template1_app.cpp``中定义的是``应用程序``是可变的。
为了灵活修改可变的部分，如修改app.Step2()的判断条件，考虑使用模板方法：

应用模板方法：
``template2_lib.h``
```cpp
#include <iostream>

using namespace std;

//程序库开发人员
class Library
{
  public:
    //稳定 template method
    void Run()
    {
        Step1();

        if (Step2()) //支持变化 ==> 虚函数的多态调用
        { 
            Step3();
        }

        Step4(); //支持变化 ==> 虚函数的多态调用

        Step5();
    }
    virtual ~Library() {}

  protected:
    void Step1()
    { //稳定
        cout << "Step1" << endl;
    }
    void Step3()
    { //稳定
        cout << "Step3" << endl;
    }
    void Step5()
    {   //稳定
        cout << "Step5" << endl;
    }

    virtual bool Step2() = 0; //变化
    virtual void Step4() = 0; //变化
};
```

``template2_app.cpp``
```cpp
#include "template2_lib.cpp"
#include <iostream>

using namespace std;

//应用程序开发人员
class Application : public Library
{
  protected:
	virtual bool Step2()
	{
		//... 子类重写实现
		cout << "override Step2" << endl;
		return true;
	}

	virtual void Step4()
	{
		//... 子类重写实现
		cout << "override Step4" << endl;
	}
};

int main()
{
	Library *pLib = new Application();
	pLib->Run();

	delete pLib;
}
```
分析：将原本main()函数中的执行流程抽象为一个类，将原本library中不变的方法保留，将可变的方法抽象为纯虚函数，供子类继承父类后重写方法。