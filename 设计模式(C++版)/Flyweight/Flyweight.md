# Flyweight 享元
享元模式（Flyweight Pattern）属于结构型设计模式，其核心思想在于通过共享技术有效支持大量细粒度的对象，减少对象的创建，从而降低系统的内存消耗，提高效率。享元模式通过区分内部状态（Intrinsic State）和外部状态（Extrinsic State）来实现这一点。内部状态是存储在享元对象内部、可以共享的状态；而外部状态是随环境改变而改变、不能共享的状态，需要由客户端维护。

## 动机(Motivation)
+ 在软件系统采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时代价——主要指内存需求方面的代价。
+ 如何在避免大量细粒度对象问题的同时，让外部客户程序仍然能够透明地使用面向对象的方式来进行操作？

## 模式定义
运行共享技术有效地支持大量细粒度的对象。
——《设计模式》GoF

## 要点总结
+ 面向对象很好地解决了抽象性的问题，但是作为yield运行机器中的程序实体，我们需要考虑对象的代价问题，
Flyweight主要解决面向对象的大家问题，一般不触及面向对象的抽象性问题。
+ Flyweight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的压力。在具体实现方面，要注意对象状态的处理。
+ 对象的数量太大从而导致对象内存开销加大——什么样的数量才算大？这需要我们仔细的根据具体应用情况进行评估，而不能凭空臆断。


## 详细
### 实现要点
1. 抽象享元角色（Flyweight）：定义享元对象的接口，声明操作方法，部分或全部操作可能依赖于外部状态。
2. 具体享元角色（Concrete Flyweight）：实现抽象享元的接口，包含内部状态。
3. 非享元角色（Unshared Concrete Class）：并非所有的类都需要共享，该角色用来处理那些不需要共享的状态。
4. 享元工厂角色（Flyweight Factory）：创建并管理享元对象，确保享元对象可以被系统适当地共享。通常使用一个享元池来存储享元对象，以供重复使用。

### 优点
1. 提高性能：通过重用对象，减少对象创建和销毁的开销，特别是在处理大量相似对象时效果显著。
2. 节约内存：共享相同状态的对象，减少了内存占用。
3. 易于维护：集中管理共享对象，使得状态变更更易于控制和维护。

### 注意事项
1. 状态分离：需要将对象的状态分为内部状态和外部状态。内部状态是共享的，不随环境变化而变化；外部状态是对象特有的，可能会随着环境的不同而有所改变。
2. 管理复杂性：为了使对象可以共享，可能需要引入额外的逻辑来管理共享对象，这会增加系统的复杂性。
3. 线程安全：在多线程环境中，享元池的管理需要考虑线程安全问题。
4. 外部状态的处理：读取享元对象的外部状态可能会导致运行时间稍微变长，因为需要额外的查找和访问操作。

## 深入理解享元模式
理解细粒度对象：细粒度对象是指那些数量众多但彼此之间差异不大的对象，这些对象是享元模式适用的典型场景。
掌握共享机制：了解如何构建享元池，以及如何在需要时从中获取对象并设置外部状态，使得它们在使用时具有不同的表现。

### 实际开发
1. 大量相似对象：当系统中存在大量相似或相同的对象时，且大部分状态都可以共享,可以使用享元模式来减少内存占用和提高性能。
2. 细粒度对象的复用：如果系统中的对象都很相似，状态变化很小，可以实现对象的多次复用，这时使用享元模式是非常合适的。
3. 性能要求高的场景：对于对性能要求较高的系统，使用享元模式可以有效减少对象的创建和管理成本，提高系统的响应速度和处理能力。
4. 资源密集型应用：如图形处理、大数据处理等，需要大量对象但内存资源紧张的应用。
5. 配置管理：系统配置信息的管理，如数据库连接参数、UI主题设置等，可以使用享元模式减少重复配置对象的创建。

### 面向对象特性的体现
1. 封装: 享元模式通过将内部状态（Intrinsic State）封装在享元对象内部，而将外部状态（Extrinsic State）委托给客户端管理，清晰地区分了对象状态的职责归属，体现了封装的原则。

2. 多态: 享元类定义了抽象接口，而具体的享元类实现了这些接口，这利用了多态特性，使得享元对象可以被统一管理和使用，而不必关心它们的具体类型。

3. 继承: 享元模式中，通过定义抽象享元类和具体享元类，利用继承关系组织不同类型的享元，使得系统设计更加灵活，易于扩展和维护。

### 内涵独特设计思路
1. 细粒度复用: 享元模式特别关注于如何高效地复用那些具有相似或相同内部状态的对象。这种细粒度的复用策略，有助于在内存受限或对象数量庞大的场景下提升性能。

2. 分离状态: 将对象的状态分为内部状态和外部状态，前者存储在享元内部，可以共享；后者则由客户端控制，根据不同的场景动态传入。这种分离使得享元对象可以在保持共享的同时，仍能表现出多样性。

### 设计哲学与特点
1. 优化资源使用: 享元模式的核心设计哲学在于通过共享来减少对象的数量，进而减少内存占用和创建销毁对象的开销，这是对资源高效利用的直接体现。

2. 灵活性与扩展性: 通过将不变的部分（内部状态）封装进享元，而将可变的部分（外部状态）留给客户端处理，享元模式在保证高效性的同时，也提供了高度的灵活性和扩展性。

3. 模式的适用性: 享元模式适合用于处理大量相似对象的场景，特别是这些对象的大部分状态都可以共享，而只有少部分状态需要根据环境变化时。例如，在图形渲染中，大量相同的图标或字符就可以通过享元模式来高效管理。

4. 权衡考量: 虽然享元模式能显著提升性能，但也增加了系统的复杂性，特别是在管理外部状态和确保线程安全方面。设计时需要权衡共享带来的好处与额外的管理开销。

## 举例
这个例子基于一个简单的文本编辑器场景，其中存在大量的字符对象需要显示。为了优化内存使用，我们将使用享元模式来共享字符对象，因为许多字符可能是重复的（如空格、标点符号等）。

```cpp
#include <iostream>
#include <map>
#include <string>

// 抽象享元角色
class Character {
public:
    virtual ~Character() {}
    virtual void print(std::string context) const = 0;
};

// 具体享元角色
class ConcreteCharacter : public Character {
private:
    char characterValue;
public:
    ConcreteCharacter(char value) : characterValue(value) {}

    void print(std::string context) const override {
        std::cout << "Printing character '" << characterValue << "' at context: " << context << std::endl;
    }
};

// 享元工厂角色
class CharacterFactory {
private:
    std::map<char, Character*> characterPool;
public:
    CharacterFactory() {
        // 初始化一些常用的字符到享元池中
        for (char c = 'a'; c <= 'z'; ++c) {
            characterPool[c] = new ConcreteCharacter(c);
        }
    }

    ~CharacterFactory() {
        for (auto& pair : characterPool) {
            delete pair.second;
        }
    }

    Character* getCharacter(char c) {
        auto it = characterPool.find(c);
        if (it != characterPool.end()) {
            return it->second;
        } else {
            // 如果字符不在池中，则创建一个新的
            Character* newChar = new ConcreteCharacter(c);
            characterPool[c] = newChar;
            return newChar;
        }
    }
};

// 客户端代码示例：

int main() {
    CharacterFactory factory;

    // 获取并打印字符'a'
    Character* charA = factory.getCharacter('a');
    charA->print("Text start");

    // 再次获取字符'a'，但这次应该从享元池中复用
    Character* anotherCharA = factory.getCharacter('a');
    anotherCharA->print("Another text position");

    return 0;
}
```
在这个例子中，Character是抽象享元角色，定义了所有字符对象的接口。ConcreteCharacter是具体享元角色，实现了Character接口，并持有字符的实际值。CharacterFactory作为享元工厂角色，负责创建和管理享元对象，确保相同字符的实例能够被复用。客户端通过工厂获取字符实例，并传递不同的上下文信息（这里简化为字符串）来展示字符的打印位置，以此展示享元模式的运作。